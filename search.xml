<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BitmapData</title>
    <url>/2022/09/17/BitmapData/</url>
    <content><![CDATA[<h2 id="Bitmap图片处理的效率"><a href="#Bitmap图片处理的效率" class="headerlink" title="Bitmap图片处理的效率"></a>Bitmap图片处理的效率</h2><ol>
<li><p>在对图片进行处理时，如果每次都对 Bitmap 的对象直接处理，效率不高</p>
<blockquote>
<p><strong>原因：</strong>因为 bitmap 存储在内存中时，它的每一个像素点是被压缩编码过的，这种编码方式使得直接对其操作需要进行解压缩、编码等操作，增加了处理的时间和复杂度。而对于一些常见的图像处理操作（如旋转、裁剪、缩放等），可以使用一些专门优化过的算法，避免直接对位图数据进行操作，从而提高处理效率。此外，还可以使用硬件加速技术（如使用GPU）来加速位图处理。</p>
</blockquote>
</li>
<li><p>改进的一些方法，在每次处理图像之前，对其进行 lock ，生成对应的 BitmapData 对象</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Rectangle rect = <span class="keyword">new</span> Rectangle(<span class="number">0</span>, <span class="number">0</span>, bmp.Width, bmp.Height);</span><br><span class="line">BitmapData bmd = bmp.LockBits(rect, ImageLockMode.ReadWrite, bmp.PixelFormat);</span><br></pre></td></tr></table></figure>

<p>类似于上面这种</p>
<blockquote>
<p><strong>注：</strong>BitmapData 类是将 Bitmap 里面的像素映射成为一个一维数组，Bitmap 中一个像素为 4bytes ，分别对应为 ARGB ,而 BitmapData 中 4bytes 中颜色的排列顺序为 BGRA 。</p>
<ul>
<li>Scan0 是该一维数组对应的首地址，采用 <code>BYTE* m_p=(BYTE*)srcBitmapData.Scan0;</code> 就可以按颜色对一维数组中的像素进行访问。例如：<code>*m_p</code>为蓝色，<code>*(m_p+1)</code>为绿色</li>
<li><code>srcBitmapData.Width</code> ,  <code>srcBitmapData.Height</code> , 分别为原来二维数组中的宽、高</li>
<li><u><code>srcBitmapData.Stride</code></u>, 为一行的字节数，且为4的整数倍，如果不足末尾会不成4的倍数。故对 Bitmap 中的 [i][j]处的蓝色可以这样访问 <code>(j*srcBitmapData.Stride)+4*i; </code></li>
</ul>
</blockquote>
</li>
<li><p>内存释放问题</p>
</li>
<li><p><code>SrcBmp.UnlockBits(SrcBmpData);</code> 记得要释放图像，才能对 SrcBmp 进行操作</p>
</li>
<li><p>test1</p>
</li>
</ol>
]]></content>
      <categories>
        <category>随手记</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS布局整理</title>
    <url>/2022/01/23/CSS%E5%B8%83%E5%B1%80%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p><em><strong>Flexbox（弹性盒子）是最新版本的 CSS（即 CSS3）中引入的一种强大且兼容性好的布局方法。使用 flexbox，我们可以很容易地处理好页面上的元素布局，并创建可以自动缩小和放大的动态用户界面。</strong></em></p>
<p><em><strong>CSS 网格是一个较新的标准，用于构建复杂的响应布局。它通过把 HTML 元素转换为具有行和列的网格容器，以便将子元素放置在所需要的位置。</strong></em></p>
<hr>
<h1 id="CSS弹性盒子"><a href="#CSS弹性盒子" class="headerlink" title="CSS弹性盒子"></a>CSS弹性盒子</h1><h2 id="display-flex定位盒子"><a href="#display-flex定位盒子" class="headerlink" title="display:flex定位盒子"></a>display:flex定位盒子</h2><p>只要在一个元素的 CSS 中添加 <code>display: flex;</code>，就可以使用其它 flex 属性来构建响应式页面了</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>: flex;</span><br></pre></td></tr></table></figure>

<h2 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h2><blockquote>
<p>只要给父元素添加 <code>flex-direction</code> 属性，并把属性值设置为 row 或 column，即可横向排列或纵向排列它的所有子元素</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">flex-direction</span>: row-reverse;</span><br></pre></td></tr></table></figure>

<p><code>flex-direction</code>的其他可选值还有<code>row-reverse</code>和<code>column-reverse</code>。<code>flex-direction</code> 的默认值为 <code>row</code></p>
<h2 id="justify-content属性"><a href="#justify-content属性" class="headerlink" title="justify-content属性"></a>justify-content属性</h2><blockquote>
<p>对于如何<strong>沿主轴线</strong>排放 flex 项目，有几种选择</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">justify-content</span>: center;  <span class="comment">/* flex-start、flex-end、space-between、space-around、space-evenly */</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>flex-start</code>：从 flex 容器的起始位置开始排列项目。 对行来说是把项目移至左边， 对于列是把项目移至顶部。 如未设置 <code>justify-content</code> 的值，那么这就是默认值。</li>
<li><code>flex-end</code>：从 flex 容器的终止位置开始排列项目。 对行来说是把项目移至右边， 对于列是把项目移至底部。</li>
<li><code>space-between</code>：项目间保留一定间距地沿主轴居中排列。 第一个和最后一个项目被放置在容器边沿。 例如，在行中第一个项目会紧贴着容器左边，最后一个项目会紧贴着容器右边，然后其他项目均匀排布。</li>
<li><code>space-around</code>：与<code>space-between</code>相似，但头尾两个项目不会紧贴容器边缘，所有项目之间的空间均匀排布。</li>
<li><code>space-evenly</code>：头尾两个项目不会紧贴容器边缘，所有项目之间的空间均匀排布。</li>
</ul>
<h2 id="align-items属性"><a href="#align-items属性" class="headerlink" title="align-items属性"></a>align-items属性</h2><blockquote>
<p>CSS 中的 <code>align-items</code> 属性用来定义 flex 子元素<strong>沿交叉轴</strong>的对齐方式</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">align-items</span>: center; <span class="comment">/* flex-start、flex-end、stretch、baseline */</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>flex-start</code>：从 flex 容器的起始位置开始对齐项目。 对行来说，把项目移至容器顶部； 对列来说，是把项目移至容器左边。</li>
<li><code>flex-end</code>：从 flex 容器的终止位置开始对齐项目。 对行来说，把项目移至容器底部； 对列来说，把项目移至容器右边。</li>
<li><code>center</code>：把项目居中放置。 对行来说，垂直居中（项目距离顶部和底部的距离相等）； 对列来说，水平居中（项目距离左边和右边的距离相等）。</li>
<li><code>stretch</code>：拉伸项目，填满 flex 容器。 例如，排成行的项目从容器顶部拉伸到底部。 如未设置<code>align-items</code>的值，那么这就是默认值。</li>
<li><code>baseline</code>：沿基线对齐。 基线是文本相关的概念，可以认为它是字母排列的下端基准线。</li>
</ul>
<h2 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h2><blockquote>
<p>CSS flexbox 有一个把 flex 子元素拆分为多行（或多列）的特性。使用 <code>flex-wrap</code> 属性可以使项目换行展示</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">flex-wrap</span>: wrap; <span class="comment">/* nowrap、wrap-reverse */</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>nowrap</code>：默认值，不换行。</li>
<li><code>wrap</code>：如果排列以行为基准，就将行从上往下排列；如果排列以列为基准，就将列从左往右排列。</li>
<li><code>wrap-reverse</code>：如果排列以行为基准，就将行从下往上排列；如果排列以列为基准，就将列从右往左排列。</li>
</ul>
<h2 id="flex-shrink属性"><a href="#flex-shrink属性" class="headerlink" title="flex-shrink属性"></a>flex-shrink属性</h2><blockquote>
<p>flex 子元素也有很多实用属性。如果 flex 容器太小，则子元素会自动缩小。 当容器的宽度小于里面所有子元素的宽度之和时，所有子元素都会自动压缩。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">flex-shrink</span>: <span class="number">1</span>;  <span class="comment">/* 数值都行 */</span></span><br></pre></td></tr></table></figure>

<p>子元素的 <code>flex-shrink</code> 接受数值作为属性值。 数值越大，则该元素与其他元素相比会被压缩得更厉害。</p>
<p>与 <code>flex-shrink</code> 相对的是 <code>flex-grow</code>。<code>flex-grow</code> 会在容器太大时对子元素作出调整。</p>
<h2 id="flex-basis属性"><a href="#flex-basis属性" class="headerlink" title="flex-basis属性"></a>flex-basis属性</h2><blockquote>
<p><code>flex-basis</code> 属性定义了在使用 CSS 的 <code>flex-shrink</code> 或 <code>flex-grow</code> 属性对元素进行调整前，元素的初始大小</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">flex-basis</span>: <span class="number">10em</span>;</span><br></pre></td></tr></table></figure>

<p><code>flex-basis</code> 属性的单位与其他表示尺寸的属性的单位一致（<code>px</code>、<code>em</code>、<code>%</code> 等）。 如果值为 <code>auto</code>，则项目的尺寸随内容调整。</p>
<h2 id="flex短方法属性"><a href="#flex短方法属性" class="headerlink" title="flex短方法属性"></a>flex短方法属性</h2><blockquote>
<p>上面几个 flex 属性有一个简写方式。 <code>flex-grow</code>、<code>flex-shrink</code> 和 <code>flex-basis</code> 属性可以在 <code>flex</code> 中一并设置。<code>flex: 1 0 10px;</code> 会把项目属性设为 <code>flex-grow: 1;</code>、<code>flex-shrink: 0;</code> 以及 <code>flex-basis: 10px;</code>属性的默认设置是 <code>flex: 0 1 auto;</code>。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  <span class="selector-id">#box-container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#box-1</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: dodgerblue;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">2</span> <span class="number">2</span> <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-id">#box-2</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: orangered;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">1</span> <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">div</span> id=&quot;box-container&quot;&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> id=&quot;box-<span class="number">1</span>&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> id=&quot;box-<span class="number">2</span>&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>

<p>通过上面的设置，在容器大于 300px 时，<code>#box-1</code> 扩大的空间会是 <code>#box-2</code> 扩大空间的两倍；在容器小于 300px 时，前者缩小的空间会是 <code>#box-2</code> 缩小空间的两倍。 300px 是两个盒子的 <code>flex-basis</code> 属性值之和。</p>
<h2 id="order属性重新排列子元素"><a href="#order属性重新排列子元素" class="headerlink" title="order属性重新排列子元素"></a>order属性重新排列子元素</h2><blockquote>
<p><code>order</code> 属性告诉 CSS flex 容器里子元素的顺序。 默认情况下，项目排列顺序与源 HTML 文件中顺序相同。 这个属性接受数字作为参数，可以使用负数。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">order</span>: <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="align-self属性"><a href="#align-self属性" class="headerlink" title="align-self属性"></a>align-self属性</h2><blockquote>
<p>这个属性允许你调整单个子元素自己的对齐方式，而不会影响到全部子元素。 因为 <code>float</code>、<code>clear</code> 和 <code>vertical-align</code> 等调整对齐方式的属性都不能应用于 flex 子元素，所以这个属性显得十分有用</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">align-self</span>: center;</span><br></pre></td></tr></table></figure>

<p><code>align-self</code> 可设置的值与 <code>align-items</code> 的一样，并且它会覆盖 <code>align-items</code> 所设置的值。</p>
<h1 id="CSS网格"><a href="#CSS网格" class="headerlink" title="CSS网格"></a>CSS网格</h1><h2 id="grid-template-columns-添加多列"><a href="#grid-template-columns-添加多列" class="headerlink" title="grid-template-columns 添加多列"></a>grid-template-columns 添加多列</h2><blockquote>
<p>简单地添加一个网格元素并不会有任何明显的效果。 还需要明确网格的结构</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">50px</span> <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码会在网格容器中添加两列，宽度均为 50px。 <code>grid-template-columns</code> 属性值的个数表示网格的列数，每个值表示相应的列宽度。</p>
<p><code>grid-template-rows</code> 添加多行</p>
<h2 id="网格单位更改行列大小"><a href="#网格单位更改行列大小" class="headerlink" title="网格单位更改行列大小"></a>网格单位更改行列大小</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-template-columns</span>: auto <span class="number">50px</span> <span class="number">10%</span> <span class="number">2</span>fr <span class="number">1</span>fr;</span><br></pre></td></tr></table></figure>

<p>这段代码添加了五个列。 第一列的宽与它的内容宽度相等；第二列宽 50px；第三列宽是它容器的 10%；最后两列，将剩余的宽度平均分成三份，第四列占两份，第五列占一份。</p>
<blockquote>
<p><code>fr</code>：设置列或行占剩余空间的比例，</p>
<p><code>auto</code>：设置列宽或行高自动等于它的内容的宽度或高度，</p>
<p><code>%</code>：将列或行调整为它的容器宽度或高度的百分</p>
</blockquote>
<h2 id="grid-column-row-gap创建间距"><a href="#grid-column-row-gap创建间距" class="headerlink" title="grid-column(row)-gap创建间距"></a>grid-column(row)-gap创建间距</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-column</span>-<span class="attribute">gap</span>: <span class="number">10px</span>; </span><br></pre></td></tr></table></figure>

<p>这会为我们创建的所有列之间都添加 10px 的空白间距。</p>
<blockquote>
<p>如果 <code>grid-gap</code> 只有一个值，那么这个值表示行与行之间、列与列之间的间距均为这个值。 如果有两个值，那么第一个值表示行间距，第二个值表示列间距。</p>
</blockquote>
<h2 id="grid-column-控制空间大小"><a href="#grid-column-控制空间大小" class="headerlink" title="grid-column 控制空间大小"></a>grid-column 控制空间大小</h2><blockquote>
<p>假想的水平线和垂直线被称为线（lines）。 这些线在网格的左上角从 1 开始编号，垂直线向右、水平线向下累加计数。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/FLASHyan/image@master/img-path/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E7%BA%BF.6d8ryl900jc0.jpg" alt=" 3x3 网格的线条"></p>
<p>如果要占据前两列</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-column</span>: <span class="number">1</span> / <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>grid-row</code> 属性来定义一个网格项开始和结束的水平线。</p>
<h2 id="justify-self-水平对齐"><a href="#justify-self-水平对齐" class="headerlink" title="justify-self 水平对齐"></a>justify-self 水平对齐</h2><blockquote>
<p>在 CSS 网格中，每个网格项的内容分别位于被称为单元格（cell）的框内。 可以使用网格项的 <code>justify-self</code> 属性，设置其内容的位置在单元格内沿水平轴的对齐方式。 默认情况下，这个属性的值是 <code>stretch</code>，这将使内容占满整个单元格的宽度</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">justify-self: stretch;</span><br></pre></td></tr></table></figure>

<p><code>start</code>：使内容在单元格左侧对齐，</p>
<p><code>center</code>：使内容在单元格居中对齐，</p>
<p><code>end</code>：使内容在单元格右侧对齐，</p>
<p>也可以设置网格项沿竖直方向的对齐方式。可以对网格项使用 <code>align-self</code> 属性来实现。</p>
<p>也可以对网格容器使用 <code>justify-items</code> 使它们一次性沿水平轴对齐。它会将网格中 <strong>所有</strong> 的网格项按所设置的方式对齐。</p>
<p>使用 <code>align-items</code> 属性可以让网格中所有的网格项沿竖直方向对齐。</p>
<h2 id="区域模板"><a href="#区域模板" class="headerlink" title="区域模板"></a>区域模板</h2><h3 id="grid-template-area"><a href="#grid-template-area" class="headerlink" title="grid-template-area"></a>grid-template-area</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-template-areas</span>:</span><br><span class="line">  <span class="string">&quot;header header header&quot;</span></span><br><span class="line">  <span class="string">&quot;advert content content&quot;</span></span><br><span class="line">  <span class="string">&quot;advert footer footer&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>上面的代码将网格单元格分成四个区域：<code>header</code>、<code>advert</code>、<code>content</code> 和 <code>footer</code>。 每个单词代表一个单元格，每对引号代表一行。</p>
<h3 id="grid-area"><a href="#grid-area" class="headerlink" title="grid-area"></a>grid-area</h3><blockquote>
<p>在为网格添加区域模板后，可以通过引用所定义的区域的名称，将元素放入相应的区域</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: header;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果网格中没有定义区域模板，也可以像这样为它添加一个模板</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">item1 &#123; <span class="attribute">grid-area</span>: <span class="number">1</span>/<span class="number">1</span>/<span class="number">2</span>/<span class="number">4</span>; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="repeat-函数减少重复"><a href="#repeat-函数减少重复" class="headerlink" title="repeat 函数减少重复"></a>repeat 函数减少重复</h2><blockquote>
<p>使用 <code>grid-template-columns</code> 或 <code>grid-template-rows</code> 定义网格结构时，你需要为添加的每一行或每一列都输入一个值。更好的方式是使用 <code>repeat</code> 方法指定行或列的重复次数，后面加上逗号以及需要重复的值</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-template-rows</span>: <span class="built_in">repeat</span>(<span class="number">100</span>, <span class="number">50px</span>);</span><br></pre></td></tr></table></figure>

<p>添加 100 行网格的例子，每行高度均为 50px</p>
<blockquote>
<p>还可以用 repeat 方法重复多个值，并在定义网格结构时与其他值一起使用</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">2</span>, <span class="number">1</span>fr <span class="number">50px</span>) <span class="number">20px</span>;</span><br><span class="line"><span class="comment">/* 两者效果是一样的 */</span></span><br><span class="line"><span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">50px</span> <span class="number">1</span>fr <span class="number">50px</span> <span class="number">20px</span>;</span><br></pre></td></tr></table></figure>

<h2 id="minmax-函数限制项目大小"><a href="#minmax-函数限制项目大小" class="headerlink" title="minmax 函数限制项目大小"></a>minmax 函数限制项目大小</h2><blockquote>
<p>内置函数 <code>minmax</code> 也可用于设置 <code>grid-template-columns</code> 和 <code>grid-template-rows</code> 的值。 它的作用是在网格容器改变大小时限制网格项的大小。 为此，需要指定网格项允许的尺寸范围</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="built_in">minmax</span>(<span class="number">50px</span>, <span class="number">200px</span>);</span><br></pre></td></tr></table></figure>

<p>第一列宽度为 100px，第二列宽度最小值是 50px，最大值是 200px。</p>
<h2 id="auto-fill-弹性布局"><a href="#auto-fill-弹性布局" class="headerlink" title="auto-fill 弹性布局"></a>auto-fill 弹性布局</h2><blockquote>
<p>repeat 方法带有一个名为自动填充（auto-fill）的功能。 它的功能是根据容器的大小，尽可能多地放入指定大小的行或列。 可以通过结合 <code>auto-fill</code> 和 <code>minmax</code> 来更灵活地布局。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">repeat(auto-fill, minmax(<span class="number">60px</span>, <span class="number">1</span>fr));</span><br></pre></td></tr></table></figure>

<p>列的宽度会随容器大小改变。其次，只要容器宽度不足以插入一个宽为 60px 的列，当前行的所有列就都会一直拉伸。<strong>如果容器宽度不足以将所有网格项放在同一行，余下的网格项将会移至新的一行</strong>。</p>
<h3 id="auto-fit"><a href="#auto-fit" class="headerlink" title="auto-fit"></a>auto-fit</h3><p><code>auto-fit</code> 效果几乎和 <code>auto-fill</code> 一样。 不同点仅在于，当容器的大小大于各网格项之和时，<code>auto-fill</code> 会持续地在一端放入空行或空列，这样就会使所有网格项挤到另一边；<strong>而 <code>auto-fit</code> 则不会在一端放入空行或空列，而是会将所有网格项拉伸至合适的大小</strong>。</p>
<h2 id="使用媒体查询创建响应式布局"><a href="#使用媒体查询创建响应式布局" class="headerlink" title="使用媒体查询创建响应式布局"></a>使用媒体查询创建响应式布局</h2><blockquote>
<p>将 CSS 网格与使用媒体查询结合使用，如使用媒体查询重新排列网格区域、更改网格尺寸以及重新排列网格项位置，可以让制作出的网站更具响应性</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">300px</span>)&#123;</span><br><span class="line">    <span class="selector-class">.container</span>&#123;</span><br><span class="line">      <span class="attribute">grid-template-columns</span>: auto <span class="number">1</span>fr;</span><br><span class="line">      <span class="attribute">grid-template-rows</span>: auto <span class="number">1</span>fr auto;</span><br><span class="line">      <span class="attribute">grid-template-areas</span>:</span><br><span class="line">        <span class="string">&quot;advert header&quot;</span></span><br><span class="line">        <span class="string">&quot;advert content&quot;</span></span><br><span class="line">        <span class="string">&quot;advert footer&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/FLASHyan/image@master/img-path/%E5%8F%AF%E8%A7%86%E5%8C%BA%E5%9F%9F.1wfl2w1515wg.jpg" alt="可视区域"></p>
<p>当网页可视区域的宽不小于 300px 时，列数从 1 变为 2。 并且，<strong>广告（advertisement）区域会完全占据左列</strong>。</p>
<h2 id="在网格中创建网格"><a href="#在网格中创建网格" class="headerlink" title="在网格中创建网格"></a>在网格中创建网格</h2><blockquote>
<p>设置 class 为 <code>item3</code> 的元素的 <code>display</code> 和 <code>grid-template-columns</code> 属性，就会得到一个嵌套的网格</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item3</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: PaleTurquoise;</span><br><span class="line">    <span class="attribute">grid-area</span>: content;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: auto <span class="number">1</span>fr;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如果把某个子元素设置为网格，就会得到一个嵌套的网格。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML标签整理</title>
    <url>/2022/01/08/HTML%E6%A0%87%E7%AD%BE%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>整理一些HTML的标签</p>
<h2 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><br><span class="line">  副标题</span><br><span class="line"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>h1、h2这一类表示的正标题副标题的标签</p>
<h2 id="段落标签"><a href="#段落标签" class="headerlink" title="段落标签"></a>段落标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  段落标签</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>所有的<code>img</code>元素必须有<code>alt</code>属性，<code>alt </code>的属性值有两个作用，<strong>第一个作用是让屏幕阅读器可以知晓图片的内容，这会对网页的可访问性有很大提升；另一个作用是当图片无法加载时，页面需要显示的替代文本</strong></p>
<h2 id="网页跳转"><a href="#网页跳转" class="headerlink" title="网页跳转"></a>网页跳转</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span> 网页跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>网页的跳转分为外部链接和内部链接，当是外部链接时，可以是对应的URL，当是内部链接时，<code>href=&quot;#xxx&quot;</code>，要在xxx前加上一个<code>#</code>，而xxx对应的是元素的<code>id</code></p>
<h2 id="无序列表和有序列表"><a href="#无序列表和有序列表" class="headerlink" title="无序列表和有序列表"></a>无序列表和有序列表</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span> 无序列表<span class="tag">&lt;/<span class="name">li</span>&gt;</span>  <span class="comment">&lt;!--无序列表--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span> 有序列表<span class="tag">&lt;/<span class="name">li</span>&gt;</span> <span class="comment">&lt;!-- 有序列表--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="文本输入框"><a href="#文本输入框" class="headerlink" title="文本输入框"></a>文本输入框</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;&quot;</span> <span class="attr">required</span>&gt;</span> <span class="comment">&lt;!-- 占位符文本placeholder-&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>input</code>输入框是没有结束标签的</p>
<h2 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h2><p>可以只通过 HTML 来实现发送数据给服务器的表单， 只需要给 <code>form</code> 元素添加 <code>action</code> 属性即可</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">required</span>&gt;</span>  <span class="comment">&lt;!--必选字段--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">    提交按钮</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="单选和复选"><a href="#单选和复选" class="headerlink" title="单选和复选"></a>单选和复选</h3><blockquote>
<p>每一个单选和复选都要嵌套在<code>label</code>标签里，设置上<code>for</code>属性，让其值与关联的<code>input</code>的<code>id</code>属性值相同；所有关联的单选和复选都应该有相同的<code>name</code>属性</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;danxuan&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;danxuan&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span>&gt;</span>单选<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;fuxuan&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;fuxuan&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span>&gt;</span>复选<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>提交表单时，所选项的值会发送给服务端。 <code>radio</code> 和 <code>checkbox</code> 的 <code>value</code> 属性值决定了发送到服务端的实际内容</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;danxuan&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;danxuan&quot;</span> <span class="attr">value</span>=<span class="string">&quot;danxuan&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span>&gt;</span>单选<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;fuxuan&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;fuxuan&quot;</span> <span class="attr">value</span>=<span class="string">&quot;fuxuan&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span>&gt;</span>复选<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在<code>input</code>中添加<code>checked</code>属性表示单选和复选框有默认选择</p>
<h2 id="内容划分元素"><a href="#内容划分元素" class="headerlink" title="内容划分元素"></a>内容划分元素</h2><blockquote>
<p><code>div</code> 元素也叫内容划分元素，是一个包裹其他元素的通用容器。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="HTML5标签"><a href="#HTML5标签" class="headerlink" title="HTML5标签"></a>HTML5标签</h2><h3 id="article标签"><a href="#article标签" class="headerlink" title="article标签"></a>article标签</h3><blockquote>
<p><code>article</code> 是一个分段标签，用于呈现独立及完整的内容。 这个标签适用于博客、论坛帖子或者新闻文章</p>
</blockquote>
<p><code>section</code> 元素也是 HTML5 引入的新元素，其语义与 <code>article</code> 略有不同。 <code>article</code> 用于独立且完整的内容，而 <code>section</code> 用于对与主题相关的内容进行分组。 它们可以根据需要来嵌套使用</p>
<h3 id="header标签"><a href="#header标签" class="headerlink" title="header标签"></a>header标签</h3><blockquote>
<p><code>header</code> 也是一个具有语义化的、可以提升页面可访问性的 HTML5 标签。 它可以为父级标签呈现简介信息或者导航链接，适用于那些在多个页面顶部重复出现的内容</p>
</blockquote>
<p>与 <code>main</code> 类似，<code>header</code> 的语义化特性也可以让辅助工具快速定位到它的内容</p>
<h3 id="nav标签和footer标签"><a href="#nav标签和footer标签" class="headerlink" title="nav标签和footer标签"></a>nav标签和footer标签</h3><blockquote>
<p><code>nav</code> 也是一个具有语义化特性的 HTML5 标签，它可以使屏幕阅读器快速识别出页面中的导航信息。 它用于呈现页面中的主导航链接</p>
</blockquote>
<p><code>footer</code> 元素也具有语义化的特性，可以让辅助工具快速定位到它。 它位于页面底部，用于呈现版权信息或者相关文档链接</p>
<h3 id="audio标签"><a href="#audio标签" class="headerlink" title="audio标签"></a>audio标签</h3><blockquote>
<p>HTML5 的 <code>audio</code> 标签用于呈现音频内容或音频流，它也具有语义化特性</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">id</span>=<span class="string">&quot;meowClip&quot;</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;audio/meow.mp3&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/mpeg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;audio/meow.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/ogg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>audio</code> 标签支持 <code>controls</code> 属性， 用于显示浏览器默认播放、停止和其他控制，以及支持键盘功能。 这是一个布尔值属性，意味着它不需要一个值，它在标签上存在即开启设置</p>
<h3 id="figure标签"><a href="#figure标签" class="headerlink" title="figure标签"></a>figure标签</h3><blockquote>
<p>HTML5 引入了 <code>figure</code> 标签以及与之相关的 <code>figcaption</code> 标签。 它们一起用于展示可视化信息（如：图片、图表）及其标题，通过语义化对内容进行分组并配以用于解释 <code>figure</code> 的文字，可以极大地提升内容的可访问性</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;roundhouseDestruction.jpeg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Photo of Camper Cat executing a roundhouse kick&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span></span><br><span class="line">    Master Camper Cat demonstrates proper form of a roundhouse kick.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意 <code>figcaption</code> 包含在 <code>figure</code> 标签中，并且可以与其他标签组合使用</p>
<h3 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a>label标签</h3><blockquote>
<p><code>label</code> 标签的文本内容通常会是表单组件的名称或标签。 这些文本表明了组件的意义，也提升了表单的可访问性。 <code>label</code> 标签的 <code>for</code> 属性将标签与表单组件绑定；同时，屏幕阅读器也会读取 <code>for</code> 属性的属性值</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;name&quot;</span>&gt;</span>Name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>for</code> 的属性值必须与表单组件的 <code>id</code> 属性值相同</p>
<h3 id="fieldset标签"><a href="#fieldset标签" class="headerlink" title="fieldset标签"></a>fieldset标签</h3><blockquote>
<p><code>fieldset</code> 标签包裹整组<strong>单选按钮</strong>，实现这个功能。 它经常使用 <code>legend</code> 标签来提供分组的描述，以便屏幕阅读器用户会阅读 <code>fieldset</code> 元素中的每个选项</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">legend</span>&gt;</span> Choose one of these three items: <span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;one&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;items&quot;</span> <span class="attr">value</span>=<span class="string">&quot;one&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;one&quot;</span>&gt;</span>Choice One<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;two&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;items&quot;</span> <span class="attr">value</span>=<span class="string">&quot;two&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;two&quot;</span>&gt;</span>Choice Two<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;three&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;items&quot;</span> <span class="attr">value</span>=<span class="string">&quot;three&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;three&quot;</span>&gt;</span>Choice Three<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当选项的含义很明确时，如“性别选择”，<code>fieldset</code> 与 <code>legend</code> 标签可以省略。 这时，使用包含 <code>for</code> 属性的 <code>label</code> 标签就足够了</p>
<h3 id="日期选择器"><a href="#日期选择器" class="headerlink" title="日期选择器"></a>日期选择器</h3><blockquote>
<p>表单中经常出现 <code>input</code> 标签，它可以用来创建多种表单控件。 它的 <code>type</code> 属性指定了所要创建的 <code>input</code> 标签类型。HTML5 规范添加了 <code>date</code> 类型来创建日期选择器</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;input1&quot;</span>&gt;</span>Enter a date:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;input1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="标准化时间"><a href="#标准化时间" class="headerlink" title="标准化时间"></a>标准化时间</h3><blockquote>
<p>HTML5 还引入了 <code>time</code> 标签与 <code>datetime</code> 属性来标准化时间。 <code>time</code> 元素是一个行内元素，用于在一个页面上显示日期或时间</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">time</span> <span class="attr">datetime</span>=<span class="string">&quot;2022-01-22&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">time</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS基础整理</title>
    <url>/2022/01/10/CSS%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="更改文本颜色"><a href="#更改文本颜色" class="headerlink" title="更改文本颜色"></a>更改文本颜色</h2><blockquote>
<p>修改<code>h2</code>元素的<code>style</code>属性来改变文本颜色，需要修改<code>color</code>属性值。需要在内联 <code>style</code> 声明末尾加上 <code>;</code></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">style</span>=<span class="string">&quot; color: red;&quot;</span>&gt;</span> 更改颜色 <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h2><blockquote>
<p>在代码的顶部，创建一个 <code>style</code> 声明区域</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"> </span></span><br><span class="line"><span class="language-css">   <span class="selector-tag">h2</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span> :blue;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以为所有的<code>h2</code>元素创建一个<em>css selector</em></p>
<h2 id="class选择器"><a href="#class选择器" class="headerlink" title="class选择器"></a>class选择器</h2><blockquote>
<p>CSS 的 class 具有可重用性，可应用于各种 HTML 元素，class选择器可设置单个元素的样式，以<code>.</code>为句首</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">   <span class="selector-class">.red-text</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;red-txet&quot;</span>&gt;</span> 文本 <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="内外边距、边框"><a href="#内外边距、边框" class="headerlink" title="内外边距、边框"></a>内外边距、边框</h2><h3 id="添加边框"><a href="#添加边框" class="headerlink" title="添加边框"></a>添加边框</h3><blockquote>
<p>CSS 边框具有 <code>style</code>、<code>color</code>、<code>width</code> 属性</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">   .border &#123;</span></span><br><span class="line"><span class="language-xml">     border-color: red;</span></span><br><span class="line"><span class="language-xml">     border-width: 5px;</span></span><br><span class="line"><span class="language-xml">     border-style: solid;  <span class="comment">&lt;!--实线--&gt;</span></span></span><br><span class="line"><span class="language-xml">     border-radius: 10px;  <span class="comment">&lt;!--边框圆角程度，也可以设置成50%--&gt;</span></span></span><br><span class="line"><span class="language-xml">   &#125;</span></span><br><span class="line"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>记得在一个元素上可以同时应用多个 <code>class</code>，使用空格来分隔不同 class 即可</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot; class1 class2&quot;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="内边距"><a href="#内边距" class="headerlink" title="内边距"></a>内边距</h3><blockquote>
<p>内边距<code>padding</code>，<code>padding</code> 用来控制着元素内容与 <code>border</code> 之间的空隙大小，还可以设置四个不同方向的 <code>padding</code> 值</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">padding-top: 10px;</span><br><span class="line">padding-left: 10px;</span><br><span class="line">padding-right: 20px;</span><br><span class="line">padding-bottom: 20px;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/FLASHyan/image@master/img-path/%E5%86%85%E5%A4%96%E8%BE%B9%E8%B7%9D.6telm81o1v40.webp" alt="内外边距"></p>
<h3 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h3><blockquote>
<p>外边距 <code>margin</code> 用来控制元素的边框与其他元素之间的 <code>border</code> 距离，增加蓝色的 <code>margin</code> 值，它也会增加元素边框到其他周围元素的距离</p>
</blockquote>
<p>在内外边距的设置里，可以按照<strong>顺时针</strong>顺序进行排序：上、右、下、左</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">padding: 10px 20px 10px 20px;</span><br></pre></td></tr></table></figure>

<h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><blockquote>
<p>使用 <code>[attr=value]</code> 属性选择器</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[type=<span class="string">&#x27;radio&#x27;</span>]</span> &#123;</span><br><span class="line">   <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0px</span> <span class="number">10px</span> <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承样式"><a href="#继承样式" class="headerlink" title="继承样式"></a>继承样式</h2><blockquote>
<p>设置 <code>body</code> 元素样式的方法跟设置其他 HTML 元素样式的方式一样，并且其他元素也会继承 <code>body</code> 中所设置的样式</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">     <span class="attribute">color</span>: green;</span></span><br><span class="line"><span class="language-css">     <span class="attribute">background</span>: black;</span></span><br><span class="line"><span class="language-css">     <span class="attribute">font-family</span>: monospace;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">   Hello World</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>Class 选择器的优先级高于继承样式</strong></p>
</li>
<li><p><strong>ID 选择器优先级高于 Class 选择器</strong></p>
</li>
<li><p><strong>内联样式的优先级高于 ID 选择器</strong></p>
</li>
<li><p><strong>Important 的优先级最高</strong>(<code>!important</code>)</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">&quot;orange-text&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;pink-text blue-text&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">&quot;color: white&quot;</span>  &lt;!<span class="attr">--行内样式--</span>&gt;</span></span><br><span class="line">&gt;</span><br><span class="line">    Hello World!</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义CSS变量"><a href="#自定义CSS变量" class="headerlink" title="自定义CSS变量"></a>自定义CSS变量</h2><blockquote>
<p>为创建一个 CSS 变量，只需要在变量名前添加两个连字符号，并为其赋值即可</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attr">--penguin-skin</span>: gray;</span><br></pre></td></tr></table></figure>

<h3 id="使用自定义CSS变量"><a href="#使用自定义CSS变量" class="headerlink" title="使用自定义CSS变量"></a>使用自定义CSS变量</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="built_in">var</span>(--penguin-skin);</span><br></pre></td></tr></table></figure>

<p>除非变量名称完全匹配，否则将不会应用样式</p>
<h3 id="CSS变量设置备用值"><a href="#CSS变量设置备用值" class="headerlink" title="CSS变量设置备用值"></a>CSS变量设置备用值</h3><blockquote>
<p>使用变量来作为 CSS 属性值的时候，可以设置一个备用值来防止由于某些原因导致变量不生效的情况</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="built_in">var</span>(--penguin-skin, balck)</span><br></pre></td></tr></table></figure>

<p>备用值不是用于增强浏览器的兼容性，它也不适用于 IE 浏览器。 相反，它是用来让浏览器在找不到你的变量时可以显示一种颜色</p>
<h3 id="继承CSS变量"><a href="#继承CSS变量" class="headerlink" title="继承CSS变量"></a>继承CSS变量</h3><blockquote>
<p>CSS 变量经常会定义在 :root 元素内，这样就可被所有选择器继承</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">   <span class="attr">--penguin-belly</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>:root</code> 是一个伪类选择器，它是一个能够匹配文档根元素的选择器，通常指的是 <code>html</code> 元素。 在 <code>:root</code> 里创建变量在全局都可用，即在任何选择器里都生效</p>
<p>如果在元素里创建相同的变量，会<strong>重写</strong>作用于整个页面的变量的值</p>
<h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><blockquote>
<p>当屏幕小于或大于媒体查询所设置的值，只要更新变量的值，那么使用了此变量的元素样式就都会更改</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">350px</span>)&#123;</span><br><span class="line">  <span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">     ****</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图片自适应设备尺寸"><a href="#图片自适应设备尺寸" class="headerlink" title="图片自适应设备尺寸"></a>图片自适应设备尺寸</h2><blockquote>
<p>设置 <code>max-width</code> 值为 <code>100%</code> 可确保图片不超出父容器的范围；设置 <code>height</code> 属性为 <code>auto</code> 可以保持图片的原始宽高比</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">  <span class="attribute">max-width</span>:<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="排版随尺寸响应"><a href="#排版随尺寸响应" class="headerlink" title="排版随尺寸响应"></a>排版随尺寸响应</h2><blockquote>
<p>可以用视窗单位来做响应式排版，视窗单位和百分比都是相对单位，但它们是基于不同的参照物</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; <span class="attribute">width</span>: <span class="number">30vw</span>; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>vw</code>：如 <code>10vw</code> 的意思是视窗宽度的 10%。</li>
<li><code>vh：</code> 如 <code>3vh</code> 的意思是视窗高度的 3%。</li>
<li><code>vmin：</code> 如 <code>70vmin</code> 的意思是视窗的高度和宽度中较小一个的 70%。</li>
<li><code>vmax：</code> 如 <code>100vmax</code> 的意思是视窗的高度和宽度中较大一个的 100%。</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-HashMap</title>
    <url>/2021/05/22/Java%E5%9F%BA%E7%A1%80-Hashmap/</url>
    <content><![CDATA[<h1 id="什么是HashMap"><a href="#什么是HashMap" class="headerlink" title="什么是HashMap?"></a>什么是HashMap?</h1><p>&ensp;&ensp;&ensp;&ensp;简单点来说，HashMap 是一个散列表，它的存储内容是键值对（key—value）映射</p>
<p>&ensp;&ensp;&ensp;&ensp;我们需要用算术操作将键（key）转化为数组的索引来访问数组中的键值对，这个算术操作其实就是找到一个合适的散列函数来将查找的键转化为数组的一个索引。理想情况下，不同的键能转化为不同的索引值，不过，如果出现两个或多个键都会散列到相同的索引值，就会发生<code>散列冲突</code>（也叫哈希冲突），具体解决方法会另外介绍。</p>
<p>&ensp;&ensp;&ensp;&ensp;HashMap 实现了 Map 接口，根据键的 HashCode 值存储数据，访问速度很快。其实哈希表的主干就是数组，因为在不考虑哈希冲突的情况下，仅仅只需要一次定位就能找到，这和数组的特点很像。</p>
<p>&ensp;&ensp;&ensp;&ensp;HashMap 的 key 和 value 的类型可以相同也可以不同，可以都是字符串(String)型的，也可以 key 是整型(Integer)、value 是字符串型的。<strong>HashMap 中的元素实际上是对象，一些常见的基本类型可以使用它的包装类</strong>。</p>
<h1 id="HashMap的使用及方法"><a href="#HashMap的使用及方法" class="headerlink" title="HashMap的使用及方法"></a>HashMap的使用及方法</h1><p>这里我们简单的介绍一下 HashMap 类的一些方法。</p>
<p>HashMap 类位于 java.util包中，使用前需要引用它，语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;		<span class="comment">// 引入HashMap类</span></span><br></pre></td></tr></table></figure>

<p>我们创建一个实例，HashMap 对象 pairs ，整型的 key 和字符串型的 value ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Integer,String&gt; pairs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,String&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><p>添加键值对可以使用 <code>put() </code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 HashMap 对象 pairs</span></span><br><span class="line">        HashMap&lt;Integer, String&gt; pairs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, String&gt;();</span><br><span class="line">        <span class="comment">// 添加键值对</span></span><br><span class="line">        pairs.put(<span class="number">1</span> , <span class="string">&quot;one&quot;</span>);</span><br><span class="line">        pairs.put(<span class="number">2</span> , <span class="string">&quot;two&quot;</span>);</span><br><span class="line">        pairs.put(<span class="number">3</span> , <span class="string">&quot;three&quot;</span>);</span><br><span class="line">        pairs.put(<span class="number">4</span> , <span class="string">&quot;four&quot;</span>);</span><br><span class="line">        System.out.println(pairs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">1</span>=one, <span class="number">2</span>=two, <span class="number">3</span>=three, <span class="number">4</span>=four&#125;</span><br></pre></td></tr></table></figure>

<h2 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h2><p>我们可以使用<code>get(key)</code>方法来获取 key 对应的 value</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 HashMap 对象 pairs</span></span><br><span class="line">        HashMap&lt;Integer, String&gt; pairs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, String&gt;();</span><br><span class="line">        <span class="comment">// 添加键值对</span></span><br><span class="line">        pairs.put(<span class="number">1</span> , <span class="string">&quot;one&quot;</span>);</span><br><span class="line">        pairs.put(<span class="number">2</span> , <span class="string">&quot;two&quot;</span>);</span><br><span class="line">        pairs.put(<span class="number">3</span> , <span class="string">&quot;three&quot;</span>);</span><br><span class="line">        pairs.put(<span class="number">4</span> , <span class="string">&quot;four&quot;</span>);</span><br><span class="line">        System.out.println(pairs.get(<span class="number">3</span>));		<span class="comment">// 获取对应的 value 值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的结果是 <code>three</code></p>
<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>我们可以使用 <code>remove(key) </code>方法来删除 key 对应的键值对(key-value):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 HashMap 对象 pairs</span></span><br><span class="line">        HashMap&lt;Integer, String&gt; pairs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, String&gt;();</span><br><span class="line">        <span class="comment">// 添加键值对</span></span><br><span class="line">        pairs.put(<span class="number">1</span> , <span class="string">&quot;one&quot;</span>);</span><br><span class="line">        pairs.put(<span class="number">2</span> , <span class="string">&quot;two&quot;</span>);</span><br><span class="line">        pairs.put(<span class="number">3</span> , <span class="string">&quot;three&quot;</span>);</span><br><span class="line">        pairs.put(<span class="number">4</span> , <span class="string">&quot;four&quot;</span>);</span><br><span class="line">        pairs.remove(<span class="number">4</span>);</span><br><span class="line">        System.out.println(pairs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">1</span>=one, <span class="number">2</span>=two, <span class="number">3</span>=three&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除所有键值对"><a href="#删除所有键值对" class="headerlink" title="删除所有键值对"></a>删除所有键值对</h3><p>可以使用 <code>clear()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 HashMap 对象 pairs</span></span><br><span class="line">        HashMap&lt;Integer, String&gt; pairs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, String&gt;();</span><br><span class="line">        <span class="comment">// 添加键值对</span></span><br><span class="line">        pairs.put(<span class="number">1</span> , <span class="string">&quot;one&quot;</span>);</span><br><span class="line">        pairs.put(<span class="number">2</span> , <span class="string">&quot;two&quot;</span>);</span><br><span class="line">        pairs.put(<span class="number">3</span> , <span class="string">&quot;three&quot;</span>);</span><br><span class="line">        pairs.put(<span class="number">4</span> , <span class="string">&quot;four&quot;</span>);</span><br><span class="line">        pairs.clear();</span><br><span class="line">        System.out.println(pairs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样哈希表中所有的键值对就都被删除了。</p>
<h2 id="迭代HashMap"><a href="#迭代HashMap" class="headerlink" title="迭代HashMap"></a>迭代HashMap</h2><p>可以使用 for-each 来迭代 HashMap 中的元素。</p>
<p>如果你只想获取 key，可以使用 <code>keySet() </code>方法，然后可以通过 <code>get(key) </code>获取对应的 value，如果你只想获取 value，可以使用 <code>values() </code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 HashMap 对象 pairs</span></span><br><span class="line">        HashMap&lt;Integer, String&gt; pairs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, String&gt;();</span><br><span class="line">        <span class="comment">// 添加键值对</span></span><br><span class="line">        pairs.put(<span class="number">1</span> , <span class="string">&quot;one&quot;</span>);</span><br><span class="line">        pairs.put(<span class="number">2</span> , <span class="string">&quot;two&quot;</span>);</span><br><span class="line">        pairs.put(<span class="number">3</span> , <span class="string">&quot;three&quot;</span>);</span><br><span class="line">        pairs.put(<span class="number">4</span> , <span class="string">&quot;four&quot;</span>);</span><br><span class="line">        <span class="comment">// 输出 key 和 value</span></span><br><span class="line">        <span class="keyword">for</span> (Integer i: pairs.keySet())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key:&quot;</span> + i + <span class="string">&quot;  value:&quot;</span> + pairs.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回所有 value 的值</span></span><br><span class="line">        <span class="keyword">for</span> (String value: pairs.values())&#123;</span><br><span class="line">            System.out.print(value + <span class="string">&quot; , &quot;</span>);    <span class="comment">// 输出所有 value 的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">key:<span class="number">1</span>  value:one</span><br><span class="line">key:<span class="number">2</span>  value:two</span><br><span class="line">key:<span class="number">3</span>  value:three</span><br><span class="line">key:<span class="number">4</span>  value:four</span><br><span class="line">one , two , three , four , </span><br></pre></td></tr></table></figure>

<h1 id="Java-HashMap-方法"><a href="#Java-HashMap-方法" class="headerlink" title="Java HashMap 方法"></a>Java HashMap 方法</h1><p>以下是常用方法：</p>
<table>
<thead>
<tr>
<th align="left"><a href="https://www.runoob.com/java/java-hashmap-clear.html">clear()</a></th>
<th align="left">删除 hashMap 中的所有键&#x2F;值对</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-clone.html">clone()</a></td>
<td align="left">复制一份 hashMap</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-isempty.html">isEmpty()</a></td>
<td align="left">判断 hashMap 是否为空</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-size.html">size()</a></td>
<td align="left">计算 hashMap 中键&#x2F;值对的数量</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-put.html">put()</a></td>
<td align="left">将键&#x2F;值对添加到 hashMap 中</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-putall.html">putAll()</a></td>
<td align="left">将所有键&#x2F;值对添加到 hashMap 中</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-putifabsent.html">putIfAbsent()</a></td>
<td align="left">如果 hashMap 中不存在指定的键，则将指定的键&#x2F;值对插入到 hashMap 中。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-remove.html">remove()</a></td>
<td align="left">删除 hashMap 中指定键 key 的映射关系</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-containskey.html">containsKey()</a></td>
<td align="left">检查 hashMap 中是否存在指定的 key 对应的映射关系。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-containsvalue.html">containsValue()</a></td>
<td align="left">检查 hashMap 中是否存在指定的 value 对应的映射关系。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-replace.html">replace()</a></td>
<td align="left">替换 hashMap 中是指定的 key 对应的 value。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-replaceall.html">replaceAll()</a></td>
<td align="left">将 hashMap 中的所有映射关系替换成给定的函数所执行的结果。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-get.html">get()</a></td>
<td align="left">获取指定 key 对应对 value</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-getordefault.html">getOrDefault()</a></td>
<td align="left">获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-foreach.html">forEach()</a></td>
<td align="left">对 hashMap 中的每个映射执行指定的操作。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-entryset.html">entrySet()</a></td>
<td align="left">返回 hashMap 中所有映射项的集合集合视图。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-keyset.html">keySet()</a></td>
<td align="left">返回 hashMap 中所有 key 组成的集合视图。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-values.html">values()</a></td>
<td align="left">返回 hashMap 中存在的所有 value 值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-merge.html">merge()</a></td>
<td align="left">添加键值对到 hashMap 中</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-compute.html">compute()</a></td>
<td align="left">对 hashMap 中指定 key 的值进行重新计算</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-computeifabsent.html">computeIfAbsent()</a></td>
<td align="left">对 hashMap 中指定 key 的值进行重新计算，如果不存在这个 key，则添加到 hasMap 中</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-computeifpresent.html">computeIfPresent()</a></td>
<td align="left">对 hashMap 中指定 key 的值进行重新计算，前提是该 key 存在于 hashMap 中。</td>
</tr>
</tbody></table>
<h1 id="关于HashSet"><a href="#关于HashSet" class="headerlink" title="关于HashSet"></a>关于HashSet</h1><p>&ensp;&ensp;&ensp;&ensp;Set 不保存重复的元素。Set 中最常被使用的是测试归属性，可以很容易查询某个对象是否在某个 Set 中。查找成了 Set 中最重要的操作。</p>
<p>&ensp;&ensp;&ensp;&ensp;HashSet 是基于 HashMap 来实现的。</p>
<ul>
<li>添加元素可以使用 <code>add()</code> 方法</li>
<li>可以使用 <code>contains()</code> 方法来判断元素是否存在于集合当中</li>
</ul>
<p>参考文章：</p>
<ul>
<li><a href="https://urlify.cn/u2YJVb">Java集合之一—HashMap</a></li>
<li><a href="https://urlify.cn/2qUnEj">什么是散列表？</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html">Java 8官方文档–HashMap</a></li>
<li><a href="https://www.runoob.com/java/java-hashmap.html">菜鸟教程</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>lowBit与质数优化</title>
    <url>/2022/04/04/lowbit%E4%B8%8E%E8%B4%A8%E6%95%B0%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="lowBit"><a href="#lowBit" class="headerlink" title="lowBit"></a>lowBit</h1><p><strong>lowBit</strong>一般用在树状数组里，主要功能是: 找到x的二进制数的最后一个1所表示的二进制</p>
<p>比如x&#x3D;6&#x3D;00000110 (2)，-x&#x3D;x(补)&#x3D;11111010(2)，lowBit(x)&#x3D;10(2)&#x3D;2</p>
<p>也就是说,就是lowbit(x)的值必然是<strong>2的幂次</strong>(最高位为1,其他位为0)</p>
<table>
<thead>
<tr>
<th>x</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>lowbit(x)</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>4</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>8</td>
<td>1</td>
</tr>
</tbody></table>
<ul>
<li>注意: x不能等于0, 否则会进入死循环, 所以树状数组通常使用的下标会执行+1操作</li>
</ul>
<blockquote>
<p>lowbit只有一行操作，而且是位运算，效率很高</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">lowBit</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的应用后面在树状数组里讲</p>
<h1 id="质数优化"><a href="#质数优化" class="headerlink" title="质数优化"></a>质数优化</h1><p>之前在LeetCode里看到这么一个题</p>
<blockquote>
<p>给两个整数 <code>left</code> 和 <code>right</code> ，在闭区间 <code>[left, right]</code> 范围内，统计并返回 <strong>计算置位位数为质数</strong> 的整数个数。</p>
<ul>
<li><code>1 &lt;= left &lt;= right &lt;= 10^6^</code></li>
<li><code>0 &lt;= right - left &lt;= 10^4^</code></li>
</ul>
</blockquote>
<p>ep：6的二进制为110，有2个计算置位</p>
<h2 id="质数优化思路"><a href="#质数优化思路" class="headerlink" title="质数优化思路"></a>质数优化思路</h2><p>可以注意到right&lt;&#x3D;10^6^&lt;2^20^，能知道的是二进制中1的个数不会超过19，不超过19的质数有 2,3,5,7,11,13,17,19；</p>
<p>可以用mask&#x3D;10100010100010101100(2)&#x3D;665772来存储这些质数，从低到高第i位为1表示i为质数</p>
<p>设整数 x 的二进制中 1 的个数为 c，若 mask按位与 2^c^ 不为 0，则说明 c是一个质数</p>
<blockquote>
<p>可以用 1 &lt;&lt; c来表示2^c^</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countPrimeSetBits</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> left;x &lt;= right;++x)&#123;</span><br><span class="line">            <span class="keyword">if</span>(((<span class="number">1</span> &lt;&lt; Integer.bitCount(x)) &amp; <span class="number">665772</span>) !=<span class="number">0</span>)&#123;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Integer.bitCount( int i)</code> 这个方法是jdk自带的帮我们快速统计i转成二进制补码后，其中二进制数中包含1的数量</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始搭建博客(hexo+github)</title>
    <url>/2021/04/24/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>本篇文章主要会讲如何借用hexo框架来简单搭建一个属于自己的博客(基于Windows系统)，从前期准备到部署到github上一个时间并不长的流程。同时通过这种整理成册的方式来加深自己的印象(<del>不希望还有重新搭建的回忆</del>)，因为时间的问题，首次整理流程可能会有遗漏或者错误的地方，我会收集反馈和时不时检查来处理这些问题，下面就开始博客搭建之旅吧。</strong></p>
<h1 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h1><p>首先我们要安装两个重要的东西，他们是Git和node</p>
<p>node下载地址：<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a>   (下载LTS版本，即长期支持版本，hexo需要node.js来支持)</p>
<p>Git下载地址：<a href="https://git-scm.com/">https://git-scm.com/</a></p>
<p>安装就一直点下一步直到安装结束就行了</p>
<p>安装好了这两个东西后可以在桌面鼠标右键选择git bash here打开git控制台</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> node <span class="literal">-v</span></span><br><span class="line"><span class="variable">$</span> npm <span class="literal">-v</span></span><br></pre></td></tr></table></figure>

<p>可以分别执行这两个操作来查看自己的node和npm的版本</p>
<p><img src="https://cdn.jsdelivr.net/gh/FLASHyan/image@master/img-path/4-24.1.76e7eqei4xk0.PNG" alt="查看版本"></p>
<p>初次使用git控制台，会让你注册，就是填邮箱和你的名称(自定义就行)</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git config <span class="literal">--global</span> user.email <span class="string">&quot;你的邮箱&quot;</span></span><br><span class="line">git config <span class="literal">--global</span> user.name <span class="string">&quot;名称&quot;</span></span><br></pre></td></tr></table></figure>

<p>他会出现这样上面这样的两行代码，你可以右键复制，一个个配置</p>
<h1 id="配置Hexo"><a href="#配置Hexo" class="headerlink" title="配置Hexo"></a>配置Hexo</h1><h2 id="安装cnpm"><a href="#安装cnpm" class="headerlink" title="安装cnpm"></a>安装cnpm</h2><p>在正式安装hexo框架前，还需要一个步骤，就是给我们的npm下载一个淘宝镜像源。因为我们的hexo是要npm这个包管理器来安装的，但是npm国内的镜像源速度很慢而且可能会漏东西。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> npm install <span class="literal">-g</span> cnpm <span class="literal">--registry</span>=http://registry.npm.taobao.org	    <span class="comment">#安装淘宝的cnpm 管理器</span></span><br></pre></td></tr></table></figure>

<p>之后都可以用cnpm来代替npm了</p>
<h2 id="安装Hexo框架"><a href="#安装Hexo框架" class="headerlink" title="安装Hexo框架"></a>安装Hexo框架</h2><p>现在来安装我们的hexo框架</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> cnpm install <span class="literal">-g</span> hexo<span class="literal">-cli</span>  <span class="comment">#安装hexo框架</span></span><br></pre></td></tr></table></figure>

<p>等待一会，下载完毕，同样你也可以通过<code>$ hexo -v </code>来查看hexo的版本</p>
<p>之后，选择你电脑中的一个位置新建一个文件夹，我的是在D盘下新建了一个blog文件夹，进入这个文件夹</p>
<p>在这个目录下git bash，我们要用hexo来生成我们的博客(&#x3D;&#x3D;记住有关下面没有明确说的git命令都是在这个文件夹下执行的&#x3D;&#x3D;)</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> hexo init    <span class="comment">#初始化</span></span><br></pre></td></tr></table></figure>

<p>命令完成之后，你的文件夹下面就会生成很多文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/FLASHyan/image@master/img-path/4.24-2.68kw8cgr01c0.PNG" alt="可以不用和我的一样"></p>
<p> 到这里，hexo已经安装好了，我们可以来启动我们的博客</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> hexo s   <span class="comment"># s就是start，启动我们的博客</span></span><br></pre></td></tr></table></figure>

<p>我们会得到一个地址<a href="http://localhost:4000/">http://localhost:4000</a>,这个就是你没部署前可以访问的端口，但是断开就看不到了，不过后期部署后可以在页面渲染后用这个地址来提前预览</p>
<hr>
<p>我们的博客基本都是要使用markdown语法来写，你可以使用vscode或者typora来写你的md文件，不过相对来说改文件配置我倾向于vscode(<em>体积小，打开快，就是一些语法环境需要在里面装插件和改配置</em>)，写博客文章就用typora就好了。(<em>不过要学习一下markdown的语法，没关系很简单</em>)</p>
<hr>
<h1 id="在github部署"><a href="#在github部署" class="headerlink" title="在github部署"></a>在github部署</h1><p>当然，首先你要去github注册一个用户名，直接百度第一个就是，这一步自行注册</p>
<h2 id="生成ssh公钥"><a href="#生成ssh公钥" class="headerlink" title="生成ssh公钥"></a>生成ssh公钥</h2><p>注册好后我们先来配置我们的ssh公钥</p>
<p>在桌面git bash，执行以下的命令(可以直接按三次回车生成密钥)</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ssh<span class="literal">-keygen</span> <span class="literal">-t</span> rsa</span><br></pre></td></tr></table></figure>

<p>生成的文件默认在~&#x2F;.ssh目录中，看到有id_rsa，id_rsa.pub这些文件即可， Win10中就是 我的电脑&#x2F;C盘&#x2F;用户&#x2F;你自己的用户名&#x2F;.shh&#x2F; 就可以看到了,将id_rsa.pub这个文件在记事本中打开，复制里面的密钥。</p>
<p><img src="https://cdn.staticaly.com/gh/FLASHyan/image@master/img-path/4.24-3.3hcpwra4t2w0.png" alt="进入设置"></p>
<p>进入github，点击右上角头像进入setting</p>
<p><img src="https://cdn.staticaly.com/gh/FLASHyan/image@master/img-path/4.24-4.4m8k5ba1kzy0.png" alt="进入ssh配置"></p>
<p>点击ssh and gpg keys</p>
<p><img src="https://cdn.staticaly.com/gh/FLASHyan/image@master/img-path/4.24-5.2fl86gx6knvo.png" alt="key"></p>
<p>把你刚刚在那个文件里复制的密钥粘贴进这个key里面，直接确认</p>
<h2 id="构建仓库"><a href="#构建仓库" class="headerlink" title="构建仓库"></a>构建仓库</h2><p>点击github头像左边的+号，选择New repository创建一个新的仓库</p>
<p><img src="https://cdn.staticaly.com/gh/FLASHyan/image@master/img-path/4.24-6.24wtnkihsdog.png" alt="创建新仓库"></p>
<p>Repository name里面的格式必须是<code>你的github用户名.github.io</code>，Description中你想填什么都可以，仓库必须是Public的，之后点创建仓库就OK了，这个仓库以后就是你存放博客的仓库，他会管理你的代码。</p>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>仓库建好后，我们需要下载一个部署插件</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> cnpm install hexo<span class="literal">-deployer-git</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure>

<h2 id="deploy配置"><a href="#deploy配置" class="headerlink" title="deploy配置"></a>deploy配置</h2><p>安装好后，在我们的博客根目录下，点击<code>_config.yml</code>来配置</p>
<p><img src="https://cdn.jsdelivr.net/gh/FLASHyan/image@master/img-path/4.24-7.676dsr01vu80.png" alt="配置文件"></p>
<p>可以用记事本或者vscode打开，当然我更推荐vscode，因为可以搜关键字，打开文件后</p>
<p><img src="https://cdn.jsdelivr.net/gh/FLASHyan/image@master/img-path/4.24-8.wxwzo1yhajk.png" alt="配置deploy"></p>
<p>翻到最下面，按照图中的格式来书写代码，注意冒号后面要有一个空格</p>
<p><em><strong>关于repo</strong></em></p>
<p><img src="https://cdn.jsdelivr.net/gh/FLASHyan/image@master/img-path/4.24-9.76ell65gr6s0.png" alt="repo地址"></p>
<p>可以选择HTTPS或者SSH，复制框中的内容，粘贴在repo里</p>
<p><em><strong>关于branch</strong></em>(即分支)</p>
<p>最近github的默认分支换成了main，不过我觉得还是master更好一点，下面来换默认分支</p>
<p>点击仓库内的setting(注意是仓库内的)，点击Branchs，在default branch里点框后面的箭头按钮(switch)，把main换成master，然后update</p>
<p><code>_config.yml</code>配置好后ctr+s保存一下</p>
<h2 id="运行Hexo"><a href="#运行Hexo" class="headerlink" title="运行Hexo"></a>运行Hexo</h2><p>这时候执行下面三个命令</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> hexo clean</span><br><span class="line"><span class="variable">$</span> hexo g</span><br><span class="line"><span class="variable">$</span> hexo d   <span class="comment">#也可以把二三步换成 hexo d -g 一步到位，不过刚开始还是慢慢来</span></span><br></pre></td></tr></table></figure>

<p>如果出现要你配置git按照前面的步骤去走</p>
<p>刷新github仓库，会多很多东西</p>
<p>现在可以按照刚刚的<code>uername.github.io</code>来进行访问啦，没出来可以等一下，因为github更新的可能会有点慢</p>
<p>页面出来后就部署完成了！</p>
<h1 id="未完的话"><a href="#未完的话" class="headerlink" title="未完的话"></a>未完的话</h1><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>hexo有很多的主题可以去使用，hexo刚初始化时会默认使用landscape主题</p>
<p>可以去hexo主题官网里去选择下载，里面会有文档配置介绍<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p>
<p>我用的是butterfly主题，他的文档介绍也是非常详细，功能什么的也很齐全（<a href="https://butterfly.js.org/%EF%BC%89">https://butterfly.js.org/）</a></p>
<h2 id="部署方案"><a href="#部署方案" class="headerlink" title="部署方案"></a>部署方案</h2><p>除了部署在github上之外，其实还可以选择gitee(码云)，这两者各有优劣</p>
<p>github的速度是比不上gitee的，gitee每次更改完博客之后部署得很快，不用等多久</p>
<p>但是gitee每次都要在gitee pages里重新更新一下，而github不用，github pages是自动部署的</p>
<p>两者的步骤都差不太多</p>
<p>PS：我现在采用的方案是<strong>vercel+github</strong>，因为国内网络的问题，github部署的速度不尽如人意，后面考虑出一期怎么部署在vercel上</p>
<p><img src="https://cdn.staticaly.com/gh/FLASHyan/image@master/img-path/vercel%E9%83%A8%E7%BD%B2.6s0z34bxzkg0.jpg" alt="vercel部署"></p>
<h2 id="图片加载问题"><a href="#图片加载问题" class="headerlink" title="图片加载问题"></a>图片加载问题</h2><p>因为要用markdown语法写文章，有时候遇到使用图片的问题</p>
<p>要么使用网络链接，要么本地链接，或者像我现在用的cdn外链，方法什么的都有</p>
<p>这里推荐一个网站：<strong><a href="https://picx.xpoet.cn/">https://picx.xpoet.cn/</a></strong></p>
<p>也是我一直在用的，里面的教程也很详细，照着一步步来就行，上传好图片到仓库后记得复制一下markdown格式的CDN外链，直接粘贴进文章里就行，方便快捷</p>
<hr>
<p>目前主要就想到这么多，后面有想到的会再加，第一次写一写教程，关于未完的话里的内容后期看看有没有机会再整几篇</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>算法练-删除链表中重复元素</title>
    <url>/2021/05/09/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>算法练中将包含相关算法和一些与考研题目结合的C语言的算法题进行延伸思考，在用Java简单实现的同时，对内容深化并尝试C语言的叙述来更加巩固当前知识点。</p>
<h1 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h1><p>存在一个按升序排列的链表，给你这个链表的头节点 <code>head</code> ，请你删除所有重复的元素，使每个元素 <strong>只出现一次</strong> 。返回同样按升序排列的结果链表。</p>
<p><img src="https://cdn.staticaly.com/gh/FLASHyan/image@master/img-path/5.8-1.1oj7ystv4nq8.png" alt="示例图"></p>
<h1 id="方法：一次遍历"><a href="#方法：一次遍历" class="headerlink" title="方法：一次遍历"></a>方法：一次遍历</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这个题的思路比较简单，因为是按升序排列的，所以重复的元素基本都是相邻着的，因此只需要比较相邻两个节点的值，就能判断出是否是重复的。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除链表中的重复元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        head.setNext(node1);</span><br><span class="line">        node1.setNext(node2);</span><br><span class="line">        node2.setNext(node3);</span><br><span class="line">        node3.setNext(node4);</span><br><span class="line">        node4.setNext(node5);</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (h != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.print(h.getData() + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            h = h.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        head = solution.deleteDuplicates(head);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;\n**********************&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印删除重复元素后的链表</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(head.getData() + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            head = head.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="comment">//算法主体</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">deleteDuplicates</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head ==<span class="literal">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur.getNext() != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//比较相邻两节点的值，若相等，就让cur的next指向下下个节点</span></span><br><span class="line">            <span class="keyword">if</span>(cur.getData() == cur.getNext().getData())&#123;</span><br><span class="line">                cur.setNext(cur.getNext().getNext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.getNext();    <span class="comment">//若相邻不相等，就让cur往后移一位</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> Data;   <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">private</span> Node next;  <span class="comment">//指针域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> Data)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.Data = Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getData</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(<span class="type">int</span> Data)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.Data = Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getNext</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Node next)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<blockquote>
<p>011335</p>
<hr>
<p>0135</p>
</blockquote>
<h2 id="算法主体"><a href="#算法主体" class="headerlink" title="算法主体"></a>算法主体</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head ==<span class="literal">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">while</span>(cur.next !=<span class="literal">null</span> )&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.val == cur.next.val )&#123;</span><br><span class="line">                    cur.next = cur.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">deleteDuplicates</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val == cur-&gt;next-&gt;val) &#123;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度：O(N)，N是链表长度</p>
<p>空间复杂度：O(1)</p>
<h1 id="扩展延伸"><a href="#扩展延伸" class="headerlink" title="扩展延伸"></a>扩展延伸</h1><h2 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h2><p><img src="https://cdn.staticaly.com/gh/FLASHyan/image@master/img-path/5.8-2.24ao3hcb35kw.jpg" alt="题图"></p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><blockquote>
<p>算法的基本设计思想</p>
</blockquote>
<ul>
<li><p>算法的核心思想是用空间来换时间。使用辅助数组来记录链表中已经出现的数值，这样只用对链表进行一次遍历</p>
</li>
<li><p>因为|data|&lt;&#x3D;0，所以辅助数组q的大小为n+1，让各个元素的初始值置为0，如果在遍历链表过程中首次出现|data|，就令这个q[|data|]为1，这样后面如果出现了第二次|data|，就可以把它从链表中删除。</p>
<p><img src="https://cdn.staticaly.com/gh/FLASHyan/image@master/img-path/5.8-3.1pzwdsxsibsw.png" alt="思路图"></p>
</li>
</ul>
<blockquote>
<p>用C语言描述单链表节点的数据类型定义</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">link</span>;</span></span><br><span class="line">&#125;NODE;</span><br><span class="line">Typedef NODE *PNODE;</span><br></pre></td></tr></table></figure>

<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span> <span class="params">(PNODE h, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  PNODE p=h, r;</span><br><span class="line">  <span class="type">int</span> *q, m;</span><br><span class="line">  q= (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(n+<span class="number">1</span>));   <span class="comment">//申请n+1个位置的辅助空间</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)</span><br><span class="line">    *(q+i) = <span class="number">0</span>;													<span class="comment">//将数组元素的初始值置为0</span></span><br><span class="line">  <span class="keyword">while</span>(p-&gt;link != null)</span><br><span class="line">  &#123;</span><br><span class="line">    m=p-&gt;link-&gt;data&gt;<span class="number">0</span>? p-&gt;link-&gt;data : -p-&gt;link-&gt;data;  <span class="comment">//判断正负，将条件全部变成绝对值</span></span><br><span class="line">    <span class="keyword">if</span>(*(q+m) == <span class="number">0</span>)				<span class="comment">//判断此时该结点data是否出现过</span></span><br><span class="line">    &#123;</span><br><span class="line">      *(q+m) = <span class="number">1</span>;   			<span class="comment">//首次出现，赋值1进行标记</span></span><br><span class="line">      p= p-&gt;link;   			<span class="comment">//保留</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>   								<span class="comment">//重复出现</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//删除该结点</span></span><br><span class="line">      r= p-&gt;link;</span><br><span class="line">      p-&gt;link = r-&gt;link;</span><br><span class="line">      <span class="built_in">free</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度：O(m)</p>
<p>空间复杂度：O(n)</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表的创建和遍历的实现(Java)</title>
    <url>/2021/04/25/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%81%8D%E5%8E%86%E7%9A%84%E5%AE%9E%E7%8E%B0(Java)/</url>
    <content><![CDATA[<p>之前站点上的文章，搬过来一下</p>
<p>（一点学习记录和问题思考）</p>
<p>创建单链表并实现数据的增删改查…</p>
<h2 id="案例内容"><a href="#案例内容" class="headerlink" title="案例内容"></a>案例内容</h2><p>将水浒英雄作为元素加进去，并且对他们进行排序输出，使用带head节点的单链表，实现一个水浒英雄排行榜管理，有两种方法:</p>
<ol>
<li>添加英雄时，直接添加到链表尾部</li>
<li>根据排名将英雄插入到指定位置（如果有这个排名，则添加失败，给出提示）</li>
</ol>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>要先创造一个头节点，作为链表的头(力扣里把他叫做哨兵节点)，因为需要判断链表是否为空</li>
<li>之后每添加一个节点，就把他放在链表的尾部</li>
<li>关键是遍历，因为有了一个头节点，且这个头节点是不能移动的(注释有讲)，所以需要一个<strong>辅助变量</strong>来遍历整个链表</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleLinkedListDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>,<span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>,<span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>,<span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>, <span class="string">&quot;公孙胜&quot;</span>,<span class="string">&quot;入云龙&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">SingleLinkedList</span> <span class="variable">singleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line">        singleLinkedList.add(hero1);</span><br><span class="line">        singleLinkedList.add(hero2);</span><br><span class="line">        singleLinkedList.add(hero3);</span><br><span class="line">        singleLinkedList.add(hero4);</span><br><span class="line"></span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义SingleLinkedList（创建链表）  管理英雄</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">//先初始化一个头节点，头节点不能动(因为动了头节点之后遍历顺序会乱)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HeroNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);  <span class="comment">//private一个头节点，这样可以确保他不会移动</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(HeroNode heroNode)</span> &#123;</span><br><span class="line">        <span class="comment">//头节点不能动，需要一个辅助变量temp遍历</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//遍历，找到链表的最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没找到最后，将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将最后节点的next指向一个新的节点</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示链表[遍历]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;  <span class="comment">//这是不为空的情况</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//将temp后移，不然会陷入死循环</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个类用于存放英雄的数据</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;  <span class="comment">//指向下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name, String nickname)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化一下</span></span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//重写toString方法,用于输出信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, nickname=&#x27;&quot;</span> + nickname + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;  <span class="comment">//next不要写进去，不然每次输出会连带着下一个节点信息输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>思考一</strong>：为什么要重写  <em><strong>toString</strong></em> 方法？</li>
</ul>
<p> 一般这个方法的作用，是将对象中各个属性值按照字符串的形式输出出来(即以文本的方式表示此对象的字符串)，但是不重写 <em><strong>toString（）</strong></em>的话,输出的就是一个内存地址(哈希码值)。</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>思考二</strong>：什么是重写？</li>
</ul>
<p> 指的是从父类继承之后，子类对于父类某方法的具体实现进行修改，你在<code>System.out.println()</code>一个对象时，是默认调用了 <em><strong>toString（）</strong></em>这个方法的，将对象转为字符串输出，<em><strong>toString（）</strong></em>方法继承于所有类的隐性基类，如果某类无重写 <em><strong>toString（）</strong></em>方法，这时调用 <em><strong>toString（）</strong></em>将得到（类名+地址名名）这样的字符串。改成别的方法名是不能称为“重写”的。重写 <em><strong>toString（）</strong></em>方法可以输出自己想要的文字信息。</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>小结</strong></li>
</ul>
<p> 这个方法可以顺利输出英雄的顺序，但是如果在main函数中改变输入英雄的编号顺序，那么输出中英雄的编号顺序也会被打乱，那么就没法实现英雄排序这么一个功能了，所以就有了另外一个方法来插入英雄。</p>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>大部分和方法一的差不多，主要关键点是找到插入的位置，判断编号是否存在，以及如何插入，与方法一一样，方法二任然需要辅助变量，来帮我们遍历链表。因为是单链表，不能找到前一个节点，所以在辅助变量移动到节点时，我们需要比较插入节点和辅助变量的下一个节点，然后根据情况是否符合将新节点插入到辅助变量后面。</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addByOrder</span><span class="params">(HeroNode heroNode)</span> &#123;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//flag标志编号是否存在，默认为false</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">//说明已经到链表的最后</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;</span><br><span class="line">                <span class="keyword">break</span>;      <span class="comment">//要让temp的下一个节点编号大于插入节点，才算找到位置</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;     <span class="comment">//编号存在，flag变为true，退出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;  <span class="comment">//后移，遍历链表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;  <span class="comment">//编号存在，不能添加</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;插入英雄的编号 %d 已经存在，不能加入\n&quot;</span>, heroNode.no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            heroNode.next = temp.next;  <span class="comment">//插入到链表中，temp后面</span></span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面是一部分，将节点插入到单链表中，<em><strong>flag</strong></em>变量的存在，用来标识编号是否存在</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 重点：关键点是节点的插入</li>
</ul>
<p> <code>heroNode.next = temp.next;</code></p>
<p> <code>temp.next = heroNode;</code></p>
<p> 我们要将节点插入到 <strong>temp</strong> 和 <strong>temp.next</strong> 之间，所以将 <strong>heroNode.next</strong> 指向 <strong>temp.next</strong> (因为 <strong>temp.next</strong> 指向的下一个节点)，这样 <strong>heroNode.next</strong> 就可以指向下一个节点，而 <strong>temp.next</strong> 指向 <strong>heroNode</strong> ，就可以完成节点的连接了。</p>
<h2 id="节点的修改"><a href="#节点的修改" class="headerlink" title="节点的修改"></a>节点的修改</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(HeroNode newHeroNode)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;   <span class="comment">//判断链表是否为空</span></span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//表示是否找到该结点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;没有找到编号为 %d 的英雄\n&quot;</span>, newHeroNode.no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>主要是要修改的节点，再针对要改的属性就行修改</p>
<p>设置一个newHeroNode变量存放修改的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HeroNode</span> <span class="variable">newHeroNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(修改的数据);</span><br><span class="line">SingleLinkedList.update(newHeroNode);</span><br></pre></td></tr></table></figure>

<p>在主函数中加入这两句即完成对节点数据的修改</p>
<h2 id="节点的删除"><a href="#节点的删除" class="headerlink" title="节点的删除"></a>节点的删除</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no == no) &#123;   <span class="comment">//要找到删除节点的前一个节点</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;  <span class="comment">//后移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.next = temp.next.next; <span class="comment">//将要删除的节点的前一个节点指向他的下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;要删除的 %d 节点不存在\n&quot;</span>, no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p> <code>temp.next = temp.next.next;</code></p>
<blockquote>
<p> 删除的操作相对比较简单，将要删除的节点的前一个节点指向他的下一个节点，那么被删除的节点就没有指向了，成为无用的节点被垃圾回收机制回收</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的图像滤波方法</title>
    <url>/2023/04/08/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="图像滤波方式"><a href="#图像滤波方式" class="headerlink" title="图像滤波方式"></a>图像滤波方式</h1><h2 id="线性滤波"><a href="#线性滤波" class="headerlink" title="线性滤波"></a>线性滤波</h2><ul>
<li><p>线性滤波是一种图像处理方法，它是通过对图像像素周围的邻域进行加权平均来实现的</p>
</li>
<li><p>它被称为线性滤波，因为它的处理过程可以用线性算子的形式表示，这使得它可以通过卷积运算来实现</p>
</li>
<li><p>线性滤波中使用的权重通常称为卷积核或滤波器。卷积核是一个二维的矩阵，用于对图像进行卷积操作。在卷积运算中，卷积核被放置在图像的每个像素上，并将其与该像素周围的邻域进行卷积操作。卷积核中的每个元素表示一个权重，它决定了该像素对于卷积运算的贡献。卷积核中的权重可以根据需要进行调整，以实现不同的滤波效果。例如，可以使用一个平均值卷积核来进行<strong>均值滤波</strong>，使用一个高斯卷积核来进行<strong>高斯滤波</strong>等等</p>
</li>
</ul>
<p>以下是一些应用场景：</p>
<blockquote>
<ol>
<li>图像去噪声：图像在传输或采集过程中会受到各种噪声的干扰，通过线性滤波可以去除图像中的噪声</li>
<li>图像平滑：有些图像具有噪声和纹理，这些会影响图像分析和处理的效果。线性滤波可以平滑图像并消除其中的纹理，从而使图像更容易分析和处理</li>
<li>图像增强：通过选择合适的滤波算法，可以对图像进行增强处理，使得图像更加清晰、细节更加明显</li>
<li>图像边缘检测：通过选择不同的滤波算法，可以对图像进行边缘检测，即提取出图像中的边缘信息</li>
<li>彩色图像处理：彩色图像通常是由多个通道组成的，线性滤波可以对各个通道分别进行处理，达到不同的效果，例如增强颜色饱和度、去除彩色图像中的噪声等</li>
</ol>
</blockquote>
<h2 id="非线性滤波"><a href="#非线性滤波" class="headerlink" title="非线性滤波"></a>非线性滤波</h2><ul>
<li><p>非线性滤波和线性滤波不太一样的点在于，非线性滤波所使用的滤波器是非线性的，通常是使用一些统计学的方法来处理图像</p>
</li>
<li><p>非线性滤波的应用场景与其特点有关，它能够在保留图像细节信息的同时去除图像中的噪声，使图像更加清晰</p>
</li>
</ul>
<p>非线性滤波的一些应用场景：</p>
<blockquote>
<ol>
<li>图像去噪：非线性滤波能够有效地去除图像中的噪声，常见的去噪滤波器包括<strong>中值滤波器</strong>、<strong>双边滤波器</strong>、<strong>非局部均值滤波器（NLMeans）</strong>等</li>
<li>边缘保护：线性滤波通常会平滑掉图像中的边缘信息，而非线性滤波能够在保留图像细节信息的同时保护边缘，常见的边缘保护滤波器包括<strong>导向滤波器</strong>、<strong>结构化边缘保护滤波器</strong>等</li>
<li>图像增强：非线性滤波能够在去除图像噪声的同时增强图像细节信息，使图像更加清晰，常见的图像增强滤波器包括<strong>非局部均值滤波器</strong>、<strong>双边滤波器</strong>等</li>
<li>彩色图像处理：非线性滤波常常用于彩色图像的处理，因为彩色图像中的不同颜色通道具有不同的统计特性，使用非线性滤波能够更好地保留彩色图像的细节信息</li>
</ol>
</blockquote>
<p>非局部均值滤波（NLMeans）利用相似块的信息来减少噪声。在该算法中，通常用相邻像素的块代替单一像素的值进行平均化，以增强噪声消除</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>其实线性滤波和非线性滤波的优劣主要取决于它们的使用场景</p>
<ul>
<li><p>线性滤波优点是它的计算简单，运算速度快但由于线性滤波是基于像素领域进行的滤波，因此会模糊图像边缘和图像细节</p>
</li>
<li><p>非线性滤波计算会更加复杂，它能够基于像素的灰度值和空间位置进行滤波，在消除噪声的同时还能保护图像细节。不过在一些场景下会产生不良的滤波效果，例如对于噪声分布不均匀的图像中，用中值滤波就无法很好地消除噪声</p>
</li>
</ul>
<p>下一篇来总结一下几种滤波的实现、原理和代码实现的步骤。</p>
]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>暴雨将至</title>
    <url>/2021/04/23/%E6%9A%B4%E9%9B%A8%E5%B0%86%E8%87%B3/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;天台上又刮起了风。</p>
<p>&ensp;&ensp;&ensp;&ensp;我站在一角，看着不知谁家的被单被风拍打地上下翻飞，开始有些担心，害怕它会被卷入这股风里，从这高处滑翔下去。风钻入我上身唯一一件白格子短袖中，头发也不听使唤地胡乱飘着。</p>
<p>&ensp;&ensp;&ensp;&ensp;闷燥的夏月，即使有风，我也能感受到一丝压迫感。天上的流云一块接一块，在仅存的微弱阳光中穿梭，终于连那最后一道光，也渐渐被吞噬掉。而我已经回到了室内走道，玻璃窗被急躁的风儿肆意敲打，我从裤兜里摸出一盒烟，快速点上一支，想在风的谢幕表演前把心中的气和烟一起吐出来，我眯着眼，望着这条狭长的走道，还没到开灯的点，这里看着就像个洗照片房里的暗室，远处只有紧急通道的灯光还在支撑，我很幸运，还能从这出去。</p>
<p>&ensp;&ensp;&ensp;&ensp;我掐灭了手里的烟，犹豫了一下，把它扔进了垃圾桶，顺手从上衣口袋中掏出了两条口香糖，我把它们塞进嘴里，糖纸被我揉成一团，一抛，没有一点声响，就落进了桶里。我径直穿过走道，直到那微弱的光从我头上掠过。</p>
<hr>
<p>&ensp;&ensp;&ensp;&ensp;朋友告诉我这是个多变的城市，可我反问他，</p>
<p>&ensp;&ensp;&ensp;&ensp; “你觉得我多变嘛？”</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;他显然被我的这个问题给吓了一跳，一时回答不上来。我看着他这个样子，不免觉得有些好笑，</p>
<p>&ensp;&ensp;&ensp;&ensp;“那你觉得她多变嘛?”</p>
<p>&ensp;&ensp;&ensp;&ensp;问题问完，他缓缓看向我，叹了口气。</p>
<p>&ensp;&ensp;&ensp;&ensp;“你们还在闹矛盾吗？事情已经过去很久了，这气也该消了吧。” </p>
<p>&ensp;&ensp;&ensp;&ensp;其实，我很想告诉他，我跟她一点矛盾也没有，只是有些时候事情就这么摆在面前，你却找不到合适的方式去开口谈起它。</p>
<p>&ensp;&ensp;&ensp;&ensp;“把问题藏在心里不是个很好的方法哦，很容易把自己憋坏的。”</p>
<p>&ensp;&ensp;&ensp;&ensp;这句话我好像跟别人也说过，当时觉得这是一句很受用的话，虽然现在也这么觉得，但它似乎已经失去了一些值得被相信的理由，但即使到了这种地步你也不得不说出这句话。</p>
<hr>
<p>&ensp;&ensp;&ensp;&ensp;我还是没等到她。</p>
<p>&ensp;&ensp;&ensp;&ensp;我看了一眼手机，列车发车时间就要到了，她发信息说她临时有事不能来送我一程，我打了一段字，写了又删，最后干脆关机，将它扔进了包里，列车门开了，下车的人，上车的人，一个个好像都是面无表情的人偶，列车驶动，这个城市的风景被高速行驶的列车甩在身后，我靠在最里面的座位上，望着阴郁的天，知道不久就会有一场大暴雨登陆这个城市，我好像有点后悔，忘了跟她说记得带伞，但我还是没有敌过倦意，揣着包就这么在车上昏睡了过去。</p>
<p>&ensp;&ensp;&ensp;&ensp;我在夜色中下了车，头发乱糟糟的。打开手机，信息还停留在几个小时前，我似乎和她保持着一种默契，就像当时朋友遇见我们时说的那种默契，虽然我一直没搞懂她在说什么。</p>
<p>&ensp;&ensp;&ensp;&ensp;我盯着忙碌的拉面师傅，他就在我面前，为下一位客人准备食物。终于，他手上的事做完了，我的面还在汤里打转。</p>
<p>&ensp;&ensp;&ensp;&ensp;“小伙子，刚从火车站出来吧，抓点紧，等会就要下雨了。”</p>
<p>&ensp;&ensp;&ensp;&ensp;“没事师傅，我包里有伞。”</p>
<p>&ensp;&ensp;&ensp;&ensp;拉面师傅欣慰地朝我点了点头，嘴角那一抹弧线让我知道他今天应该是很开心的。其实我是骗他的，我的伞在那个城市的某个地方就已经不见了。我无意提了一下，她说要给我重新买一把，被我拒绝了，伞对我来说还算不上必备品，掉了就说明它跟我无缘，等哪个有缘人捡去，说不定就是一件善事了。</p>
<p>&ensp;&ensp;&ensp;&ensp;师傅转身又开始了新一轮的忙碌，我悄无声息地离开了拉面店，走了很远，总觉得刚刚应该跟他道个别，看他这么忙，还是要说声谢谢，可惜这句话连着面一起被我吞进了肚子里。</p>
<p>&ensp;&ensp;&ensp;&ensp;下次来再跟他说。</p>
<p>&ensp;&ensp;&ensp;&ensp;前面没有路灯。</p>
<hr>
<p>&ensp;&ensp;&ensp;&ensp;果然她没带伞，淋着雨回到了住所。</p>
<p>&ensp;&ensp;&ensp;&ensp;我觉得这次没什么好多说的，毕竟是我先关机的，很多事在事发之前没能想一个好的解决办法，等到发生了才开始追悔莫及，放在以前我绝对会对这个人的能力产生怀疑，但现在发现我其实没这个资格。</p>
<p>&ensp;&ensp;&ensp;&ensp;屏幕的光照在我的脸上，我聊了很多，道了晚安，手机依然握在手里，晚安只是说给愿意做梦的人听的，但事实上不是谁都想要做梦，我一度觉得没有说晚安的必要，但它总比拜拜要好一些，我没得选择，再加个表情，让他看上去不那么僵硬。我笑了，像在表演一出喜剧，摆弄脸上的表情，演给台下昏昏欲睡的观众，台词老套，让人提不起兴趣，人们撇嘴，开始对演员产生了质疑。临场发挥我看过很多，但要我做着实有些不合适。</p>
<p>&ensp;&ensp;&ensp;&ensp;想着还有闹钟，这次我没有选择关机。</p>
<hr>
<p>&ensp;&ensp;&ensp;&ensp;时间比我预期的早了点，本想把夏季梅雨的时节熬过去再和她谈明白，但她似乎还在惦记我丢失的那把雨伞，我苦笑，她也害羞地笑，我只好跟着附和。在我的印象里，那把伞的样子早就模糊了，只是没想到她还记得这么清楚。</p>
<p>&ensp;&ensp;&ensp;&ensp;“再买一把就好了。”我挠挠头。</p>
<p>&ensp;&ensp;&ensp;&ensp;“可是你没买。”</p>
<p>&ensp;&ensp;&ensp;&ensp;“……”</p>
<p>&ensp;&ensp;&ensp;&ensp;有时我很佩服她的洞察力，她其实对很多事是心知肚明的，只是嘴上不说，等到某个时候只需要一句话就能让你哑口无言。</p>
<p>&ensp;&ensp;&ensp;&ensp;我发现再这么聊下去恐怕天黑也开不了口，于是我选择岔开话题，她有些察觉，</p>
<p>&ensp;&ensp;&ensp;&ensp;“你是不是有什么心事?”</p>
<p>&ensp;&ensp;&ensp;&ensp;我有点恍惚，感觉这是我要问的问题，被她先问了出来，我的心扑通扑通地跳动，这和我看恐怖片时的感觉很像，只不过我从来不一个人看恐怖片。</p>
<p>&ensp;&ensp;&ensp;&ensp;总感觉那段时间很漫长，也很短暂。我甚至忘了我说了什么，忘了她的表情和她说的话，我只记得我一直在提醒自己要理智，得把话快点说完，赶着最后一趟班车回去。</p>
<p>&ensp;&ensp;&ensp;&ensp;出来前看了眼天气预报，才想起来自己还没有买伞。</p>
<p>&ensp;&ensp;&ensp;&ensp;我陪着她走回了家，一路上我们两个人一句话都没说。我又想起了那个人口中的默契，似乎一切都合情合理。到了家门口，她却有点挪不动脚步，我看到她眼角微红的印记，我只是站着发呆，想的许多的话憋到了嘴边，却只说了句，</p>
<p>&ensp;&ensp;&ensp;&ensp;“拜拜，晚安。”</p>
<p>&ensp;&ensp;&ensp;&ensp;我曾经对这种莫名的默契很是苦恼，但现在我反而觉得它出现的刚刚好，不想再多言一句，把这双赢的局面给破坏了。</p>
<hr>
<p>&ensp;&ensp;&ensp;&ensp;差点没赶上回来的车，上车随便找了个位子就坐下了。我感觉到气温的上升，雨水砸在地面上，拍打着车窗，我还是没能阻止暴雨的落下，雨幕把窗外的一切都打上了模糊的标记，闷燥的车厢里氤氲着湿热的水汽，广播里传来电台主持人的声音，他们大肆地笑着，我想跟着他们一起笑，虽然我没听清他们在笑什么。如果没下雨，我想去那家拉面店把我没说出来的话补上，或者，如果我手上有伞。</p>
<hr>
<p>&ensp;&ensp;&ensp;&ensp;我阻止不了这场暴雨，阻止不了她的离开，所以只能选择阻止自己，阻止自己进入这场暴雨，阻止自己进入她的生活。</p>
<hr>
<p>&ensp;&ensp;&ensp;&ensp;“你是不是忘了说什么?”</p>
<p>&ensp;&ensp;&ensp;&ensp;她留在原地不肯动，头微微低着，但还是在试着望向我。</p>
<p>&ensp;&ensp;&ensp;&ensp;我看着她的头发被风吹散，我察觉我的泪要止不住了。</p>
<p>&ensp;&ensp;&ensp;&ensp;“你知道我会说什么，”我顿了顿，我发现我好像一个忘了台词的演员，尴尬至极。</p>
<p>&ensp;&ensp;&ensp;&ensp;“拜拜。”我转身就要走。</p>
<p>&ensp;&ensp;&ensp;&ensp;“晚安。”</p>
<p>&ensp;&ensp;&ensp;&ensp;我听见身后她细弱的声音。</p>
<p>&ensp;&ensp;&ensp;&ensp;“晚安。”</p>
<p>&ensp;&ensp;&ensp;&ensp;我说完了最后一句话。</p>
<hr>
<p>&ensp;&ensp;&ensp;&ensp;END</p>
<p>&ensp;&ensp;&ensp;&ensp;(本文由歌曲 fun&#x2F;Coldplay和rainy dumplings&#x2F;饭碗的彼岸 所感而写)</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>算法练-反转单链表</title>
    <url>/2021/04/28/%E7%AE%97%E6%B3%95%E7%BB%83-%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给单链表的头节点 <code>head</code> ，请反转链表，并返回反转后的链表。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure>

<h1 id="方法一：-双指针迭代"><a href="#方法一：-双指针迭代" class="headerlink" title="方法一： 双指针迭代"></a>方法一： 双指针迭代</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><img src="https://jsd.cdn.zzko.cn/gh/FLASHyan/image@master/img-path/fanzhuanlianbiao.5qh2agfbvps0.png" alt="迭代思路图"></p>
<p>&ensp;&ensp;&ensp;&ensp;首先要引入两个指针，分别是<code>prev</code>和<code>curr</code>,因为要把链表反转，那么就必须对next做文章，通过<code>curr</code>指针让当前节点的next指向上一个节点，而上一个节点由<code>prev</code>指针来表示。指向更改后两个指针往后移位。</p>
<p>&ensp;&ensp;&ensp;&ensp;但是在这里有一个问题，就是当<code>curr.next-&gt;prev</code>后，如图，节点1和节点2之间就断开了，那么<code>curr</code>指针就无法进行后移操作，所以我们还需要一个临时变量<code>next</code>，在将<code>curr.next-&gt;prev</code>前，先将<code>curr</code>的下一个节点暂时保存在这个临时变量<code>next</code>中，等第一个节点反转之后，<code>prev</code>后移，再将next里的值给到<code>curr</code>实现其后移。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代法实现反转链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        head.setNext(node1);</span><br><span class="line">        node1.setNext(node2);</span><br><span class="line">        node2.setNext(node3);</span><br><span class="line">        node3.setNext(node4);</span><br><span class="line">        node4.setNext(node5);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印反转前的链表</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (h != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(h.getData() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            h = h.getNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用迭代的反转方法</span></span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        head = solution.reverse(head);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n**************************&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印反转后的结果</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">null</span> != head) &#123;</span><br><span class="line">            System.out.print(head.getData() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            head = head.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="comment">//迭代算法主体部分</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">reverse</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;         <span class="comment">//判断链表是否为空</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        Node temp;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;          <span class="comment">//当curr为null，说明现在为尾结点</span></span><br><span class="line">            temp = curr.getNext();      <span class="comment">//临时变量，存放下一个节点</span></span><br><span class="line">            curr.setNext(prev);         <span class="comment">//更改next指向</span></span><br><span class="line">            <span class="comment">//两个指针后移</span></span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;    <span class="comment">//prev变为表头，返回prev</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> Data;   <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">private</span> Node next;  <span class="comment">//指针域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> Data)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.Data = Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getData</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(<span class="type">int</span> Data)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.Data = Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getNext</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Node next)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<blockquote>
<p>0 1 2 3 4 5 </p>
<hr>
<p>5 4 3 2 1 0 </p>
</blockquote>
<h2 id="算法主体"><a href="#算法主体" class="headerlink" title="算法主体"></a>算法主体</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="comment">//迭代算法主体部分</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">reverse</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;         <span class="comment">//判断链表是否为空</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        Node temp;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;          <span class="comment">//当curr为null，说明现在为尾结点</span></span><br><span class="line">            temp = curr.getNext();      <span class="comment">//临时变量，存放下一个节点</span></span><br><span class="line">            curr.setNext(prev);         <span class="comment">//更改next指向</span></span><br><span class="line">            <span class="comment">//两个指针后移</span></span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;    <span class="comment">//prev变为表头，返回prev</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">prev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">curr</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span> =</span> curr-&gt;next;</span><br><span class="line">        curr-&gt;next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度：O(N)，N是链表长度，因为需要遍历链表一次</p>
<p>空间复杂度：O(1)</p>
<h1 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><img src="https://jsd.cdn.zzko.cn/gh/FLASHyan/image@master/img-path/digui.77mpm5vqq300.png" alt="递归思路图"></p>
<p>通过不断调用函数递归，在归的过程中将节点指向反向，这里用<code>head.next.next = head;</code></p>
<p>往上的过程中，子节点已经反转好，让自己和子节点进行反转即可</p>
<p>递归结束的条件，当前链表为空或者链表里只有一个节点(因为此时不需要反转)</p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归法实现反转链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        head.setNext(node1);</span><br><span class="line">        node1.setNext(node2);</span><br><span class="line">        node2.setNext(node3);</span><br><span class="line">        node3.setNext(node4);</span><br><span class="line">        node4.setNext(node5);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印反转前的链表</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (h != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(h.getData() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            h = h.getNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用迭代的反转方法</span></span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        head = solution.reverse1(head);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n**************************&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印反转后的结果</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">null</span> != head) &#123;</span><br><span class="line">            System.out.print(head.getData() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            head = head.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="comment">//递归算法主体部分</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">reverse1</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="comment">//递归结束的条件，当前链表为空或者链表里只有一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.getNext() == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newHead</span> <span class="operator">=</span> reverse1(head.getNext());     <span class="comment">//递归调用</span></span><br><span class="line">        head.getNext().setNext(head);               <span class="comment">//节点反向</span></span><br><span class="line">        head.setNext(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> newHead;                <span class="comment">//这是反转后的表头，在函数出栈的过程中这个返回值一直没有变</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> Data;   <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">private</span> Node next;  <span class="comment">//指针域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> Data)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.Data = Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getData</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(<span class="type">int</span> Data)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.Data = Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getNext</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Node next)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法主体-1"><a href="#算法主体-1" class="headerlink" title="算法主体"></a>算法主体</h2><h3 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="comment">//递归算法主体部分</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">reverse1</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="comment">//递归结束的条件，当前链表为空或者链表里只有一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.getNext() == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newHead</span> <span class="operator">=</span> reverse1(head.getNext());     <span class="comment">//递归调用</span></span><br><span class="line">        head.getNext().setNext(head);               <span class="comment">//节点反向</span></span><br><span class="line">        head.setNext(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> newHead;                <span class="comment">//这是反转后的表头，在函数出栈的过程中这个返回值一直没有变</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归算法不太好理解，可以认为是大问题一步步分解成小问题，再返回上一级问题执行同样的操作，一步步还回去。这类问题分清楚递和归的过程。</p>
<h3 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newHead</span> =</span> reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度：O(N)，假设 N 是列表的长度，那么时间复杂度为 O(N)。<br>空间复杂度：O(N)，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 N 层。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>算法练-两数之和</title>
    <url>/2021/04/27/%E7%AE%97%E6%B3%95%E7%BB%83-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>



<h1 id="方法一-暴力枚举"><a href="#方法一-暴力枚举" class="headerlink" title="方法一: 暴力枚举"></a>方法一: 暴力枚举</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>通过枚举数组中的每一个数，组合来查找是否有适合<code>target</code>的两个整数</p>
<p>设两个数分别是x , y,他们的下标是i , j</p>
<p>两个循环，第一个找一个x，x前面的数都和x匹配过了，所以只需要去找x后面的数，即从j&#x3D;i+1开始找y</p>
<p>找到了x和y就可以将两个下标输出</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暴力枚举找出两数之和</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> nums[] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">17</span> ;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">Solution</span>().twoSum(nums, target);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : result) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;                     <span class="comment">//获取数组长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;        <span class="comment">//x只要找到倒数第二个，后面的会和x匹配</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; ++j) &#123;    <span class="comment">//i的前面不用去考虑，考虑i后面的</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<blockquote>
<p>0</p>
<p>3</p>
</blockquote>
<h2 id="算法主体"><a href="#算法主体" class="headerlink" title="算法主体"></a>算法主体</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;                     <span class="comment">//获取数组长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;        <span class="comment">//x只要找到倒数第二个，后面的会和x匹配</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; ++j) &#123;    <span class="comment">//i的前面不用去考虑，考虑i后面的</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; numsSize; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                <span class="type">int</span>* ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">2</span>);</span><br><span class="line">                ret[<span class="number">0</span>] = i, ret[<span class="number">1</span>] = j;</span><br><span class="line">                *returnSize = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度：O(N^2^)，最坏情况下数组中任意两个数都要进行匹配</p>
<p>空间复杂度：O(1)</p>
<p>对于这种情况，一般用空间去换时间，所以要进行一下优化</p>
<h1 id="方法二-哈希表"><a href="#方法二-哈希表" class="headerlink" title="方法二: 哈希表"></a>方法二: 哈希表</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>创建一个哈希表，先将数组第一个数存进去，并从第二个元素开始查找，让<code>target - nums[i]</code>与存放在哈希表中的<code>key</code>匹配，没有匹配的就存进哈希表中，如果匹配成功就输出这两个元素及下标 </p>
<p><img src="https://jsd.cdn.zzko.cn/gh/FLASHyan/image@master/img-path/hashmap.50pj6du1kxo0.png" alt="哈希表思路"></p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//哈希表</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> nums[] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">Solution</span>().twoSum(nums, target);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : result) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化哈希表，指定哈希表的容量以防止哈希表扩容带来性能的消耗</span></span><br><span class="line">        <span class="comment">//这里指定哈希表的容量为len-1，是因为最后一个元素全部比较过了</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; hashtable = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;(len -<span class="number">1</span> );</span><br><span class="line">        hashtable.put(nums[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;  <span class="comment">//从第二个开始比较</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">another</span> <span class="operator">=</span> target -nums[i];</span><br><span class="line">            <span class="keyword">if</span> (hashtable.containsKey(another)) &#123;		<span class="comment">//寻找有没有key与another对应</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;hashtable.get(another), i&#125;;	<span class="comment">//找到，返回值和下标</span></span><br><span class="line">            &#125;</span><br><span class="line">            hashtable.put(nums[i], i);		<span class="comment">//没有匹配，存入哈希表中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<blockquote>
<p>1</p>
<p>2</p>
</blockquote>
<h2 id="算法主体-1"><a href="#算法主体-1" class="headerlink" title="算法主体"></a>算法主体</h2><h3 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化哈希表，指定哈希表的容量以防止哈希表扩容带来性能的消耗</span></span><br><span class="line">        <span class="comment">//这里指定哈希表的容量为len-1，是因为最后一个元素全部比较过了</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; hashtable = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;(len -<span class="number">1</span> );</span><br><span class="line">        hashtable.put(nums[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;  <span class="comment">//从第二个开始比较</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">another</span> <span class="operator">=</span> target -nums[i];</span><br><span class="line">            <span class="keyword">if</span> (hashtable.containsKey(another)) &#123;		<span class="comment">//寻找有没有key与another对应</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;hashtable.get(another), i&#125;;	<span class="comment">//找到，返回值和下标</span></span><br><span class="line">            &#125;</span><br><span class="line">            hashtable.put(nums[i], i);		<span class="comment">//没有匹配，存入哈希表中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    UT_hash_handle hh;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">hashtable</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> hashTable* <span class="title function_">find</span><span class="params">(<span class="type">int</span> ikey)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">tmp</span>;</span></span><br><span class="line">    HASH_FIND_INT(hashtable, &amp;ikey, tmp);</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> ikey, <span class="type">int</span> ival)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">it</span> =</span> find(ikey);</span><br><span class="line">    <span class="keyword">if</span> (it == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">tmp</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> hashTable));</span><br><span class="line">        tmp-&gt;key = ikey, tmp-&gt;val = ival;</span><br><span class="line">        HASH_ADD_INT(hashtable, key, tmp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it-&gt;val = ival;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    hashtable = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">it</span> =</span> find(target - nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (it != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="type">int</span>* ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">2</span>);</span><br><span class="line">            ret[<span class="number">0</span>] = it-&gt;val, ret[<span class="number">1</span>] = i;</span><br><span class="line">            *returnSize = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        insert(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度：O(N)，其中 N 是数组中的元素数量。对于每一个元素 x，我们可以 O(1) 地寻找 target - x。</p>
<p>空间复杂度：O(N)，其中 N 是数组中的元素数量。主要为哈希表的开销。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title>算法练-反转括号间字符串</title>
    <url>/2021/05/30/%E7%AE%97%E6%B3%95%E7%BB%83-%E5%8F%8D%E8%BD%AC%E6%8B%AC%E5%8F%B7%E9%97%B4%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给出一个字符串 s（仅含有小写英文字母和括号）。</p>
<p>请你按照从<strong>括号内到外</strong>的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。</p>
<blockquote>
<p>注意，结果中不应包含任何括号。</p>
</blockquote>
<h1 id="方法一：栈"><a href="#方法一：栈" class="headerlink" title="方法一：栈"></a>方法一：栈</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>&ensp;&ensp;&ensp;&ensp;对于括号序列相关的题，通用的解法是用递归或者栈。</p>
<p>&ensp;&ensp;&ensp;&ensp;从左至右地遍历整个字符串，用字符串 <em>str</em> 来记录当前层所遍历到的小写英文字母。对于当前遍历的字母：</p>
<ul>
<li><strong>如果是左括号</strong>：把 <em>str</em> 插入到栈中，并且把 <em>str</em> 置空，进入到下一层</li>
<li><strong>如果是右括号</strong>：遍历到了右括号，说明当前层的字母已经遍历完了，把 <em>str</em> 反转，并把栈顶的字符串弹出，将反转后的 <em>str</em> 插入到弹出字符串的末尾，将结果赋值给 <em>str</em> </li>
<li><strong>如果是小写英文字母</strong>：追加到 <em>str</em> 末尾</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;可以看到，只有在遍历到了右括号（第一个出现的右括号是最里面的）才会对字符串进行操作，这样可以保证能从括号里到外处理字符串</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        System.out.println(solution.reverseParentheses(<span class="string">&quot;(u(love)i)&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用栈实现反转每对括号间的子串</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseParentheses</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        Deque&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();   <span class="comment">//对字符串进行修改时，用StringBuffer类</span></span><br><span class="line">        <span class="comment">//对字符串s进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                stack.push(sb.toString());      <span class="comment">//toString()返回序列中的字符串</span></span><br><span class="line">                sb.setLength(<span class="number">0</span>);                <span class="comment">//将字符串置空</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                sb.reverse();                   <span class="comment">//字符串反转</span></span><br><span class="line">                sb.insert(<span class="number">0</span>, stack.pop());</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(ch);                  <span class="comment">//追加字符串到此字符串中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<blockquote>
<p>iloveu</p>
</blockquote>
<h2 id="算法主体"><a href="#算法主体" class="headerlink" title="算法主体"></a>算法主体</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用栈实现反转每对括号间的子串</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseParentheses</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        Deque&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();   <span class="comment">//对字符串进行修改时，用StringBuffer类</span></span><br><span class="line">        <span class="comment">//对字符串s进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                stack.push(sb.toString());      <span class="comment">//toString()返回序列中的字符串</span></span><br><span class="line">                sb.setLength(<span class="number">0</span>);                <span class="comment">//将字符串置空</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                sb.reverse();                   <span class="comment">//字符串反转</span></span><br><span class="line">                sb.insert(<span class="number">0</span>, stack.pop());</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(ch);                  <span class="comment">//追加字符串到此字符串中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p><strong>时间复杂度</strong>：O（n^2^），其中n是字符串长度。栈的最大深度是O(n)，每一层处理的时间复杂度主要是反转的时间复杂度，为O(n)。</p>
<p><strong>空间复杂度</strong>：O(n)，n是字符串长度，在任意时刻，字符串中的任一字符只会被栈中至多一个位置包含一次。</p>
<h1 id="方法二：预处理括号"><a href="#方法二：预处理括号" class="headerlink" title="方法二：预处理括号"></a>方法二：预处理括号</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><img src="https://jsd.cdn.zzko.cn/gh/FLASHyan/image@master/img-path/%E9%A2%84%E5%A4%84%E7%90%86%E6%8B%AC%E5%8F%B7.n25z4n2n6o0.png" alt="预处理括号思路图"></p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        System.out.println(solution.reverseParentheses(<span class="string">&quot;(ed(et(oc))el)&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预处理括号</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseParentheses</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span>[] pair = <span class="keyword">new</span> <span class="title class_">int</span>[n];    <span class="comment">//创建整型数组处理括号配对</span></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                stack.push(i);      <span class="comment">//注意压栈的是数组下标</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">/**弹出的栈顶元素是代表左括号赋值给 j，但是当前 i 是右括号</span></span><br><span class="line"><span class="comment">                 * 让右括号指向左括号</span></span><br><span class="line"><span class="comment">                 * 左括号指向右括号</span></span><br><span class="line"><span class="comment">                 * **/</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                pair[i] = j;</span><br><span class="line">                pair[j] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>, step = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(index) == <span class="string">&#x27;(&#x27;</span> || s.charAt(index) == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                index = pair[index];        <span class="comment">//如果是index返回的字符串是左括号，index的值指向右括号，如果是右括号亦然</span></span><br><span class="line">                step = -step;               <span class="comment">//遍历方向反向</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(s.charAt(index));         <span class="comment">//是英文字母就加入到字符串str末尾</span></span><br><span class="line">            &#125;</span><br><span class="line">            index += step;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遇到括号就跳转到对应括号后反向遍历，这个方法很巧妙，反转即是逆向的遍历这个思想</p>
<p>输出结果：</p>
<blockquote>
<p>leetcode</p>
</blockquote>
<h2 id="算法主体-1"><a href="#算法主体-1" class="headerlink" title="算法主体"></a>算法主体</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//预处理括号</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseParentheses</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span>[] pair = <span class="keyword">new</span> <span class="title class_">int</span>[n];    <span class="comment">//创建整型数组处理括号配对</span></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                stack.push(i);      <span class="comment">//注意压栈的是数组下标</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">/**弹出的栈顶元素是代表左括号赋值给 j，但是当前 i 是右括号</span></span><br><span class="line"><span class="comment">                 * 让右括号指向左括号</span></span><br><span class="line"><span class="comment">                 * 左括号指向右括号</span></span><br><span class="line"><span class="comment">                 * **/</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                pair[i] = j;</span><br><span class="line">                pair[j] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>, step = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(index) == <span class="string">&#x27;(&#x27;</span> || s.charAt(index) == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                index = pair[index];        <span class="comment">//如果是index返回的字符串是左括号，index的值指向右括号，如果是右括号亦然</span></span><br><span class="line">                step = -step;               <span class="comment">//遍历方向反向</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(s.charAt(index));         <span class="comment">//是英文字母就加入到字符串str末尾</span></span><br><span class="line">            &#125;</span><br><span class="line">            index += step;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p><strong>时间复杂度</strong>：O(n)，其中 n 为字符串的长度。预处理出括号的对应关系的序列的时间复杂度为 O(n)，遍历字符串的时间复杂度同样为 O(n)。</p>
<p><strong>空间复杂度</strong>：O(n)，其中 n 为字符串的长度。栈的大小不会超过 n，以及我们需要 O(n) 的空间记录括号的对应关系。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>栈</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>算法练-括号匹配</title>
    <url>/2021/05/18/%E7%AE%97%E6%B3%95%E7%BB%83-%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ul>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ul>
<p>示例：{()}，()[]，都是有效匹配，{()]为无效匹配</p>
<h1 id="方法：栈"><a href="#方法：栈" class="headerlink" title="方法：栈"></a>方法：栈</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由题目可以知道，要有效匹配，就得左括号和右括号匹配，后出现的左括号总是和先出现的右括号匹配，遵循后进先出的特点，而这一特点就和栈的特点类似</p>
<p><img src="https://cdn.staticaly.com/gh/FLASHyan/image@master/img-path/5.18.3koug6uevsi0.png" alt="思路图"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        System.out.println(solution.isVaild(<span class="string">&quot;&#123;[]&#125;&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="comment">//算法主体</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isVaild</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>)&#123;                 <span class="comment">//字符串个数如果为奇数，直接输出false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;Character,Character&gt; brackets = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Character&gt;()&#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//建立一个哈希表，以右括号为键，左括号为值，组成键值对</span></span><br><span class="line">                put(<span class="string">&#x27;)&#x27;</span> , <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">                put(<span class="string">&#x27;]&#x27;</span> , <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">                put(<span class="string">&#x27;&#125;&#x27;</span> , <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把Deque作为栈来使用，Deque只是一个接口，是Qeque接口的增强，可以实现的类有ArrayDeque和Linkedlist</span></span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Character&gt;();</span><br><span class="line">        <span class="comment">//遍历所有的字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);              <span class="comment">//charAt()方法返回指定索引处的char值</span></span><br><span class="line">            <span class="keyword">if</span>(brackets.containsKey(ch))&#123;       <span class="comment">//判断是否是右括号</span></span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty() || stack.peek() != brackets.get(ch))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();        <span class="comment">//如果是右括号，且栈不为空，就让栈顶元素跟键所映射的值比较，符合就弹出当前栈顶元素</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(ch);     <span class="comment">//是左括号就入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();     <span class="comment">//若括号全部匹配，则最后栈空，不为空说明有多的左括号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法主体"><a href="#算法主体" class="headerlink" title="算法主体"></a>算法主体</h2><h3 id="Java-1"><a href="#Java-1" class="headerlink" title="Java(1)"></a>Java(1)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="comment">//算法主体</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isVaild</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>)&#123;                 <span class="comment">//字符串个数如果为奇数，直接输出false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;Character,Character&gt; brackets = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Character&gt;()&#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//建立一个哈希表，以右括号为键，左括号为值，组成键值对</span></span><br><span class="line">                put(<span class="string">&#x27;)&#x27;</span> , <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">                put(<span class="string">&#x27;]&#x27;</span> , <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">                put(<span class="string">&#x27;&#125;&#x27;</span> , <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把Deque作为栈来使用，Deque只是一个接口，是Qeque接口的增强，可以实现的类有ArrayDeque和Linkedlist</span></span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Character&gt;();</span><br><span class="line">        <span class="comment">//遍历所有的字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);              <span class="comment">//charAt()方法返回指定索引处的char值</span></span><br><span class="line">            <span class="keyword">if</span>(brackets.containsKey(ch))&#123;       <span class="comment">//判断是否是右括号</span></span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty() || stack.peek() != brackets.get(ch))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();        <span class="comment">//如果是右括号，且栈不为空，就让栈顶元素跟键所映射的值比较，符合就弹出当前栈顶元素</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(ch);     <span class="comment">//是左括号就入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();     <span class="comment">//若括号全部匹配，则最后栈空，不为空说明有多的左括号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>note</code>：建立<code>Hashmap</code>，用<code>Deque</code>接口实现<code>Linkedlist</code>类作为栈，<code>charAt()</code>方法返回索引处的 char 值，会另开文章总结</p>
<h3 id="Java-2"><a href="#Java-2" class="headerlink" title="Java(2)"></a>Java(2)</h3><p>针对此题还有一种快速的方法，利用 foreach 迭代来遍历字符串数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//算法主体</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isVaild</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Character&gt;();</span><br><span class="line">        <span class="comment">//使用foreach循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;        <span class="comment">//toCharArray()方法返回一个char数组</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty() || stack.pop() != c)      <span class="comment">//这里可以偷一个懒，直接弹出栈顶元素并比较，这样省去了用peek这一步骤</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="title function_">pairs</span><span class="params">(<span class="type">char</span> a)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="string">&#x27;&#125;&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="string">&#x27;]&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="string">&#x27;)&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> stk[n + <span class="number">1</span>], top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">char</span> ch = pairs(s[i]);</span><br><span class="line">        <span class="keyword">if</span> (ch) &#123;				<span class="comment">//s[i]为右括号，ch得到pairs返回的左括号，和栈顶元素比较</span></span><br><span class="line">            <span class="keyword">if</span> (top == <span class="number">0</span> || stk[top - <span class="number">1</span>] != ch) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            top--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;				<span class="comment">//s[i]为左括号，入栈后top指针加1</span></span><br><span class="line">            stk[top++] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C 和 Java 的原理都差不多，都是要把左括号入栈，右括号作为跳板，重点就是要与栈顶元素的匹配。观察两种语言的算法实现还是很有趣的。</p>
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度：O(n)，因为要遍历字符串 s，其中 n 是字符串 s 的长度。</p>
<p>空间复杂度：O(n+∣Σ∣)，其中 Σ 表示字符集，本题中字符串只包含 6 种括号，∣Σ∣&#x3D;6。栈中的字符数量为 O(n)，而哈希表使用的空间为 O(∣Σ∣)，相加即可得到总空间复杂度。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>算法练-最小栈的实现</title>
    <url>/2021/05/26/%E7%AE%97%E6%B3%95%E7%BB%83-%E6%9C%80%E5%B0%8F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;针对王道考研第三章（栈与队列）的拓展思考题–最小栈的实现。本文会探讨三种方法来实现，分别是辅助类、单个栈和双栈。</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>&ensp;&ensp;&ensp;&ensp;请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。</p>
<blockquote>
<p>注：这里要求的是常量级的时间里找到最小值，所以先排序、再查找是不行的，我们必须在需要的时候就要得到最小值</p>
</blockquote>
<h1 id="方法一：辅助类（链表类）"><a href="#方法一：辅助类（链表类）" class="headerlink" title="方法一：辅助类（链表类）"></a>方法一：辅助类（链表类）</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>&ensp;&ensp;&ensp;&ensp;我们知道，栈其实是一种操作受限的线性表，所以栈的一些操作可以通过链表来实现。这里要我们设计一个栈，而栈的实现我们可以使用链表，先定义一个链表类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> min;  <span class="comment">//最小值</span></span><br><span class="line">  <span class="keyword">public</span> ListNode next;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> min, ListNode next)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.val = val;</span><br><span class="line">    <span class="built_in">this</span>.min = min;</span><br><span class="line">    <span class="built_in">this</span>.next = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://jsd.cdn.zzko.cn/gh/FLASHyan/image@master/img-path/%E9%93%BE%E8%A1%A8%E7%B1%BB%E6%80%9D%E8%B7%AF%E5%9B%BE.4f3ddq5y3qi0.png" alt="链表类思路图"></p>
<p>&ensp;&ensp;&ensp;&ensp;栈中的最小值始终保存在链表的头结点，我们要获取最小值时直接返回<code>head.min</code>，即可在常量时间内完成。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MinStack</span> <span class="variable">ms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MinStack</span>();</span><br><span class="line">        ms.push(<span class="number">1</span>);</span><br><span class="line">        ms.push(<span class="number">2</span>);</span><br><span class="line">        ms.push(<span class="number">3</span>);</span><br><span class="line">        ms.push(-<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;min:&quot;</span> + ms.getMin());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode head;	<span class="comment">//定义一个头结点</span></span><br><span class="line">    <span class="comment">//压栈操作，压入val、min</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(empty())&#123;</span><br><span class="line">            head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(x, x, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(x, Math.min(x , head.min), head);	<span class="comment">// Math.min函数选出最小值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出栈操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(empty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;栈为空......&quot;</span>);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//相当于返回栈中最小值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(empty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;栈为空......&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> head.min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断栈是否为空</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义链表类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> min;</span><br><span class="line">    <span class="keyword">public</span> ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> min, ListNode next)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.min = min;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<blockquote>
<p>min：-1</p>
</blockquote>
<h2 id="算法主体"><a href="#算法主体" class="headerlink" title="算法主体"></a>算法主体</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode head;	<span class="comment">//定义一个头结点</span></span><br><span class="line">    <span class="comment">//压栈操作，压入val、min</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(empty())&#123;</span><br><span class="line">            head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(x, x, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(x, Math.min(x , head.min), head);	<span class="comment">// Math.min函数选出最小值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出栈操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(empty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;栈为空......&quot;</span>);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//相当于返回栈中最小值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(empty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;栈为空......&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> head.min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断栈是否为空</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义链表类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> min;</span><br><span class="line">    <span class="keyword">public</span> ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> min, ListNode next)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.min = min;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;通过辅助类 ListNode 来实现栈的操作，原理上还是很好懂得，结合了栈与链表相似特性，可能效果不如双栈，但不失为一种方法。</p>
<h1 id="方法二：压缩还原法（单栈）"><a href="#方法二：压缩还原法（单栈）" class="headerlink" title="方法二：压缩还原法（单栈）"></a>方法二：压缩还原法（单栈）</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>&ensp;&ensp;&ensp;&ensp;每一次入栈的元素和上一个元素都会有一个差值，如果入栈元素比上一个大，差值就会为正值，如果比上一个小，差值就会为负。那么我们的栈中只需要存入他们的差值，用一个<code>min</code>辅助变量来存储当前最小值即可。</p>
<p><strong>入栈</strong>：	</p>
<ul>
<li><p><strong>压缩</strong>：将要入栈的元素 x 减去当前最小值 min ，得到一个差值 diff ，栈中只储存该差值；</p>
</li>
<li><p><strong>更新</strong>：如果入栈的元素 x 比 min 还要小，就更新最小值，<code>min = x;</code></p>
</li>
<li><p><strong>初始</strong>：第一次入栈，栈中没有值，所以令 min &#x3D; x；</p>
</li>
</ul>
<p><strong>出栈</strong>：</p>
<ul>
<li><strong>更新</strong>：如果栈中存储的差值 diff 是负数，说明出栈的元素是当前最小值 min ，需要把 min 值更新为上一个最小值 min &#x3D; min - diff ，否则，出栈的元素不是最小值，则不对 min 变量做任何操作；</li>
<li><strong>还原</strong>：如果栈中存储的差值diff是正数，说明 top &#x3D; min + diff，否则，说明top元素本身是最小值 top &#x3D; min；</li>
</ul>
<p><img src="https://jsd.cdn.zzko.cn/gh/FLASHyan/image@master/img-path/%E5%8D%95%E4%B8%AA%E6%A0%88%E6%80%9D%E8%B7%AF%E5%9B%BE.5eg486f54o40.png" alt="单个栈思路图"></p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MinStack</span> <span class="variable">ms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MinStack</span>();</span><br><span class="line">        ms.push(<span class="number">1</span>);</span><br><span class="line">        ms.push(<span class="number">2</span>);</span><br><span class="line">        ms.push(-<span class="number">1</span>);</span><br><span class="line">        ms.push(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;min:&quot;</span> + ms.getMin());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="type">int</span> min;</span><br><span class="line">    <span class="comment">//压栈操作，设置一个辅助变量min存储最小值，栈中压入的是元素与最小值的差值，如果差值小于0，就更新最小值为当前元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x )</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">            min = x;</span><br><span class="line">            stack.push(x - min );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> x - min;</span><br><span class="line">            stack.push(diff);</span><br><span class="line">            <span class="keyword">if</span>(diff &lt; <span class="number">0</span> )</span><br><span class="line">                min = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出栈操作，弹出的差值如果是小于0的，那么说明最小值会变化，变成上一个最小值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.isEmpty())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(diff &lt; <span class="number">0</span> )&#123;</span><br><span class="line">            min = min - diff;  <span class="comment">//更新min值，</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">        <span class="keyword">if</span>(diff &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min + diff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<blockquote>
<p>min：-1</p>
</blockquote>
<h2 id="算法主体-1"><a href="#算法主体-1" class="headerlink" title="算法主体"></a>算法主体</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="type">int</span> min;</span><br><span class="line">    <span class="comment">//压栈操作，设置一个辅助变量min存储最小值，栈中压入的是元素与最小值的差值，如果差值小于0，就更新最小值为当前元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x )</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">            min = x;</span><br><span class="line">            stack.push(x - min );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> x - min;</span><br><span class="line">            stack.push(diff);</span><br><span class="line">            <span class="keyword">if</span>(diff &lt; <span class="number">0</span> )</span><br><span class="line">                min = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出栈操作，弹出的差值如果是小于0的，那么说明最小值会变化，变成上一个最小值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.isEmpty())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(diff &lt; <span class="number">0</span> )&#123;</span><br><span class="line">            min = min - diff;  <span class="comment">//更新min值，</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">        <span class="keyword">if</span>(diff &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min + diff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;只使用一个栈，通过栈存入差值，另外加入辅助变量的方法实现最小值的获取。</p>
<h1 id="方法三：双栈"><a href="#方法三：双栈" class="headerlink" title="方法三：双栈"></a>方法三：双栈</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>&ensp;&ensp;&ensp;&ensp;第三个方法就很简单了，这里我们能用两个栈，那么栈1就用来存放需要压栈的元素，栈2就存放最小值。栈2的栈顶元素就是最小值。主要分清楚两个栈的功能就行。</p>
<h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MinStack</span> <span class="variable">ms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MinStack</span>();</span><br><span class="line">        ms.push(<span class="number">1</span>);</span><br><span class="line">        ms.push(<span class="number">2</span>);</span><br><span class="line">        ms.push(-<span class="number">1</span>);</span><br><span class="line">        ms.push(-<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;min:&quot;</span> + ms.getMin());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();  <span class="comment">//栈1存放的是需要压栈的值</span></span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();  <span class="comment">//栈2存放的是最小值</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//栈2的栈顶元素就是最小值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//压栈操作，有更小的值就往栈2里压</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">        <span class="keyword">if</span>(stack2.empty() || x &lt; getMin())</span><br><span class="line">            stack2.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出栈操作，将栈1的栈顶元素弹出并与栈2的栈顶元素比较，相等的话弹出最小值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack1.pop() == stack2.peek())</span><br><span class="line">            stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<blockquote>
<p>min：-2</p>
</blockquote>
<h2 id="算法主体-2"><a href="#算法主体-2" class="headerlink" title="算法主体"></a>算法主体</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();  <span class="comment">//栈1存放的是需要压栈的值</span></span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();  <span class="comment">//栈2存放的是最小值</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//栈2的栈顶元素就是最小值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//压栈操作，有更小的值就往栈2里压</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">        <span class="keyword">if</span>(stack2.empty() || x &lt; getMin())</span><br><span class="line">            stack2.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出栈操作，将栈1的栈顶元素弹出并与栈2的栈顶元素比较，相等的话弹出最小值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack1.pop() == stack2.peek())</span><br><span class="line">            stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;两个栈的原理简化了很多，但另外两种方法的思想还是值得去研究一下得，可以更好地拓展思路。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>算法练-环形链表</title>
    <url>/2021/04/29/%E7%AE%97%E6%B3%95%E7%BB%83-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个链表，判断链表中是否有环。</p>
<p>如果链表中存在环，就返回true。否则，返回false。</p>
<p><img src="https://jsd.cdn.zzko.cn/gh/FLASHyan/image@master/img-path/shili.png" alt="示例"></p>
<h1 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这个方法就是遍历整个链表中的所有节点，每遍历一个节点就判断它此前是否被访问过</p>
<p>用哈希表来存储已经访问过的节点，之后每到达一个节点时，如果该节点已经在哈希表里，就说明这个链表中有环</p>
<p>否则就把这个节点存入进去，重复这么一个过程，直到整个链表被遍历完</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希表判断链表中是否有环</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        head.setNext(node1);</span><br><span class="line">        node1.setNext(node2);</span><br><span class="line">        node2.setNext(node3);</span><br><span class="line">        node3.setNext(node4);</span><br><span class="line">        node4.setNext(node3);</span><br><span class="line"></span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        System.out.print(<span class="string">&quot;&quot;</span> + solution.cycle(head));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="comment">//哈希表算法主体</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cycle</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        Set&lt;Node&gt; seen = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Node&gt;();   <span class="comment">//Hashset是基于Hashmap来实现的，是一个不允许有重复元素的集合</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!seen.add(head))&#123;    <span class="comment">//判断能否加入元素，若不能，说明存在环</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> Data;   <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">private</span> Node next;  <span class="comment">//指针域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> Data)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.Data = Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getData</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(<span class="type">int</span> Data)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.Data = Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getNext</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Node next)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用到了HashSet，HashSet是基于Hashmap来实现的，是一个不允许有重复元素的集合</p>
<p>添加元素用add()方法</p>
<h2 id="算法主体"><a href="#算法主体" class="headerlink" title="算法主体"></a>算法主体</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="comment">//哈希表算法主体</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cycle</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        Set&lt;Node&gt; seen = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Node&gt;();   <span class="comment">//Hashset是基于Hashmap来实现的，是一个不允许有重复元素的集合</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!seen.add(head))&#123;    <span class="comment">//判断能否加入元素，若不能，说明存在环</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度：O(N)，N是链表的节点数。最坏情况需要把链表中每一个节点遍历一次。</p>
<p>空间复杂度：O(N)，N是链表的节点数。主要是为哈希表的开销，最坏情况需要把每个节点插入到哈希表中一次。</p>
<p>思考：能不能用O(1)的空间复杂度来解决这个问题。</p>
<h1 id="方法二：快慢指针"><a href="#方法二：快慢指针" class="headerlink" title="方法二：快慢指针"></a>方法二：快慢指针</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这个方法称为Floyd判圈算法(又称为龟兔赛跑算法)</p>
<p><img src="https://jsd.cdn.zzko.cn/gh/FLASHyan/image@master/img-path/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88.38jri9mcjf40.png" alt="快慢指针思路图"></p>
<p>在开始的时候给定两个指针，一个快，一个慢</p>
<p>如果链表中存在环，那么快指针会在某一时刻追上慢指针，即二者相等，而快指针已经套了慢指针几圈了</p>
<p>如果链表不存在环，那么快指针就会先入空或指向空</p>
<p>这样循环条件都得到了</p>
<p>注意：因为判断是否追上的条件是<code>fast == slow</code>，所以<code>slow</code>一开始在head节点，那么<code>fast</code>就要在下一个节点，以防二者一开始就相等破坏循环条件。</p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快慢指针判断链表中是否有环</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        head.setNext(node1);</span><br><span class="line">        node1.setNext(node2);</span><br><span class="line">        node2.setNext(node3);</span><br><span class="line">        node3.setNext(node4);</span><br><span class="line">        node4.setNext(node3);</span><br><span class="line"></span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        System.out.print(<span class="string">&quot;&quot;</span> + solution.cycle(head));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="comment">//双指针算法主体</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cycle</span><span class="params">(Node head)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.getNext() == <span class="literal">null</span>)&#123;     <span class="comment">//链表为空或者只有一个节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义两个快慢指针</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">fast</span> <span class="operator">=</span> head.getNext();</span><br><span class="line">        <span class="keyword">while</span> (slow != fast)&#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.getNext() == <span class="literal">null</span>)&#123;    <span class="comment">//无环条件，快的那个指针先入空或者指向空</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.getNext();      <span class="comment">//慢的指针一次走一步</span></span><br><span class="line">            fast = fast.getNext().getNext();    <span class="comment">//快的指针一次走两步</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> Data;   <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">private</span> Node next;  <span class="comment">//指针域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> Data)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.Data = Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getData</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(<span class="type">int</span> Data)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.Data = Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getNext</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Node next)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法主体-1"><a href="#算法主体-1" class="headerlink" title="算法主体"></a>算法主体</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="comment">//双指针算法主体</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cycle</span><span class="params">(Node head)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.getNext() == <span class="literal">null</span>)&#123;     <span class="comment">//链表为空或者只有一个节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义两个快慢指针</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">fast</span> <span class="operator">=</span> head.getNext();</span><br><span class="line">        <span class="keyword">while</span> (slow != fast)&#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.getNext() == <span class="literal">null</span>)&#123;    <span class="comment">//无环条件，快的那个指针先入空或者指向空</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.getNext();      <span class="comment">//慢的指针一次走一步</span></span><br><span class="line">            fast = fast.getNext().getNext();    <span class="comment">//快的指针一次走两步</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">hasCycle</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span> =</span> head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度：O(N)，其中 N 是链表中的节点数。</p>
<p>当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。</p>
<p>当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 N 轮。</p>
<p>空间复杂度：O(1)。只使用了两个指针的额外空间。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉设计整理</title>
    <url>/2022/01/15/%E8%A7%86%E8%A7%89%E8%AE%BE%E8%AE%A1%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="text-align属性"><a href="#text-align属性" class="headerlink" title="text-align属性"></a>text-align属性</h2><blockquote>
<p><code>text-align</code> 属性可以控制文本的对齐方式</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">text-align</span>: justify;		将文本隔开，使每行的宽度相等</span><br><span class="line"><span class="attribute">text-align</span>: center;		可以让文本居中对齐</span><br><span class="line"><span class="attribute">text-align</span>: right;		可以让文本右对齐</span><br><span class="line"><span class="attribute">text-align</span>: left;		是默认值，它可以让文本左对齐</span><br></pre></td></tr></table></figure>

<h2 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h2><blockquote>
<p><code>box-shadow</code> 属性用来给元素添加阴影，该属性值是由逗号分隔的一个或多个阴影列表</p>
</blockquote>
<p><code>box-shadow</code> 属性的阴影依次由下面这些值描述：</p>
<ul>
<li><code>offset-x</code> 阴影的水平偏移量；</li>
<li><code>offset-y</code> 阴影的垂直偏移量；</li>
<li><code>blur-radius</code> 模糊半径；</li>
<li><code>spread-radius</code> 阴影扩展半径；</li>
<li><code>color</code></li>
</ul>
<p>其中 <code>blur-radius</code> 和 <code>spread-radius</code> 是可选的</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">10px</span> <span class="number">20px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.19</span>), <span class="number">0</span> <span class="number">6px</span> <span class="number">6px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.23</span>);</span><br></pre></td></tr></table></figure>

<h2 id="降低元素的透明度"><a href="#降低元素的透明度" class="headerlink" title="降低元素的透明度"></a>降低元素的透明度</h2><blockquote>
<p>CSS 里的 <code>opacity</code> 属性用来设置元素的透明度</p>
</blockquote>
<p>属性值为 1 代表完全不透明<br>属性值为 0.5 代表半透明<br>属性值为 0 代表完全透明</p>
<p>透明度会应用到元素内的所有内容，不论是图片，还是文本，或是背景色</p>
<h2 id="text-transform"><a href="#text-transform" class="headerlink" title="text-transform"></a>text-transform</h2><blockquote>
<p>CSS 里的 <code>text-transform</code> 属性可以改变英文字母的大小写</p>
</blockquote>
<table>
<thead>
<tr>
<th>值</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>lowercase</td>
<td>“transform me”</td>
</tr>
<tr>
<td>uppercase</td>
<td>“TRANSFORM ME”</td>
</tr>
<tr>
<td>capitalize</td>
<td>“Transform Me”</td>
</tr>
<tr>
<td>initial</td>
<td>使用默认值</td>
</tr>
<tr>
<td>inherit</td>
<td>使用父元素的 <code>text-transform</code> 值</td>
</tr>
<tr>
<td>none</td>
<td><strong>Default:</strong> 不改变文字</td>
</tr>
</tbody></table>
<h2 id="调整锚点悬停状态"><a href="#调整锚点悬停状态" class="headerlink" title="调整锚点悬停状态"></a>调整锚点悬停状态</h2><blockquote>
<p>伪类是可以添加到选择器上的关键字，用来选择特定状态的元素</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>:hover</code> 伪类选择器来选取超链接的悬停状态</p>
<h2 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h2><h3 id="更改相对位置"><a href="#更改相对位置" class="headerlink" title="更改相对位置"></a>更改相对位置</h3><blockquote>
<p>在 CSS 里一切 HTML 元素皆为盒子，也就是通常所说的<em><strong>盒模型</strong></em>。 块级元素自动从新的一行开始（比如标题、段落以及 div），行内元素排列在上一个元素后（比如图片以及 span）。 元素默认按照这种方式布局称为<em><strong>文档的普通流</strong></em>，同时 CSS 提供了 position 属性来覆盖它</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把元素的位置设置成相对，并不会改变该元素在布局中所占的位置，也不会对其它元素的位置产生影响</p>
<h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><blockquote>
<p>和 <code>relative</code> 定位不一样，绝对定位会将元素从当前的文档流里面移除，周围的元素会忽略它</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: absolute;</span><br></pre></td></tr></table></figure>

<p>绝对定位比较特殊的一点是元素的定位参照于最近的 <em><strong>positioned</strong></em> 祖先元素。 如果它的父元素没有添加定位规则（默认是 <code>position: relative;</code>），浏览器会继续寻找直到默认的 <code>body</code> 标签</p>
<h3 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h3><blockquote>
<p><code>fixed</code> 定位，它是一种特殊的绝对（absolute）定位，将元素相对于浏览器窗口定位</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: fixed;</span><br></pre></td></tr></table></figure>

<p><code>fixed</code> 和 <code>absolute</code> 的最明显的区别在于，前者定位的元素不会随着屏幕滚动而移动</p>
<h3 id="float属性"><a href="#float属性" class="headerlink" title="float属性"></a>float属性</h3><blockquote>
<p>浮动元素不在文档流中，它向 <code>left</code> 或 <code>right</code> 浮动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。 通常需要用 <code>width</code> 属性来指定浮动元素占据的水平空间</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#left</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#right</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">float</span>: right;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">40%</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">aside</span>, <span class="selector-tag">section</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">2px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;left&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Content<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Good stuff<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aside</span> <span class="attr">id</span>=<span class="string">&quot;right&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Sidebar<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Links<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/FLASHyan/image@master/img-path/float%E5%B1%9E%E6%80%A7.19onrxbygt8g.jpg" alt="float浮动"></p>
<h2 id="z-index属性"><a href="#z-index属性" class="headerlink" title="z-index属性"></a>z-index属性</h2><blockquote>
<p>当一些元素在位置上重叠时（例如，使用 <code>position: absolute | relative | fixed | sticky</code> 时），在 HTML 里后出现的元素会默认显示在更早出现的元素的上面</p>
</blockquote>
<p>可以使用 <code>z-index</code> 属性指定元素的堆叠次序。 <code>z-index</code> 的取值是整数，数值大的元素会叠放到数值小的元素上面</p>
<h2 id="元素水平居中"><a href="#元素水平居中" class="headerlink" title="元素水平居中"></a>元素水平居中</h2><blockquote>
<p>常见的实现方式是把块级元素的 <code>margin</code> 值设置为 auto</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">margin</span>: auto;</span><br></pre></td></tr></table></figure>

<p>同样的，这个方法也对图片奏效。 图片默认是<strong>内联元素</strong>，但是可以通过设置其 <code>display</code> 属性为 <code>block</code>来把它变成块级元素</p>
<h2 id="CSS线性渐变"><a href="#CSS线性渐变" class="headerlink" title="CSS线性渐变"></a>CSS线性渐变</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(gradient_direction, color <span class="number">1</span>,color <span class="number">2</span>,...)</span><br></pre></td></tr></table></figure>

<p>第一个参数指定了颜色过渡的方向——它的值是角度，<code>90deg</code> 表示垂直渐变（从左到右），<code>45deg</code> 表示沿对角线渐变（从左下方到右上方）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">35deg</span>, <span class="number">#CCFFFF</span>, <span class="number">#FFCCCC</span>);</span><br></pre></td></tr></table></figure>

<h3 id="创建条纹元素"><a href="#创建条纹元素" class="headerlink" title="创建条纹元素"></a>创建条纹元素</h3><blockquote>
<p><code>repeating-linear-gradient()</code> 函数和 <code>linear-gradient()</code> 很像，主要区别是前者会重复指定的渐变</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="number">0px</span> <span class="selector-attr">[yellow -- blend -- blue]</span> <span class="number">40px</span> <span class="selector-attr">[green -- blend -- red]</span> <span class="number">80px</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">repeating-linear-gradient</span>(</span><br><span class="line">      <span class="number">90deg</span>,</span><br><span class="line">      yellow <span class="number">0px</span>,</span><br><span class="line">      blue <span class="number">40px</span>,</span><br><span class="line">      green <span class="number">40px</span>,</span><br><span class="line">      red <span class="number">80px</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="更改元素大小"><a href="#更改元素大小" class="headerlink" title="更改元素大小"></a>更改元素大小</h2><blockquote>
<p>CSS 属性 <code>transform</code> 里面的 <code>scale()</code> 函数可以用来改变元素的显示比例</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把页面的段落元素放大到了原来的 2 倍</p>
<blockquote>
<p>还能通过伪类选择器来和元素进行交互</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样将鼠标悬停在元素上时，大小缩放成原来的1.5倍</p>
<h2 id="沿X、Y轴倾斜元素"><a href="#沿X、Y轴倾斜元素" class="headerlink" title="沿X、Y轴倾斜元素"></a>沿X、Y轴倾斜元素</h2><blockquote>
<p>用到的是<code>transform</code> 属性是<code> skewX()</code>、<code>skewY()</code></p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">skewX</span>(<span class="number">24deg</span>);</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">skewY</span>(<span class="number">24deg</span>);</span><br></pre></td></tr></table></figure>

<h2 id="伪元素before和after"><a href="#伪元素before和after" class="headerlink" title="伪元素before和after"></a>伪元素before和after</h2><blockquote>
<p><code>::before</code> 创建一个伪元素，它是所选元素的第一个子元素； <code>::after</code> 创建一个伪元素，它是所选元素的最后一个子元素</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.heart</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">25%</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">70px</span>;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>::before</code> 和 <code>::after</code> 必须配合 <code>content</code> 来使用。这个属性通常用来给元素添加内容诸如图片或者文字。</p>
<h2 id="animation属性"><a href="#animation属性" class="headerlink" title="animation属性"></a>animation属性</h2><h3 id="关键帧和动画"><a href="#关键帧和动画" class="headerlink" title="关键帧和动画"></a>关键帧和动画</h3><blockquote>
<p><code>animation-name</code> 用来设置动画的名称；<code>animation-duration</code> 设置动画所花费的时间；<code>@keyframes</code> 可以通过设置特定时间点的行为来创建动画</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#anim</span> &#123;</span><br><span class="line">  <span class="attribute">animation-name</span>: raimbow;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">4s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> rainbow &#123;		&lt;!--设置特定时间点的行为来创建动画--&gt;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">50%</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修改动画填充模式"><a href="#修改动画填充模式" class="headerlink" title="修改动画填充模式"></a>修改动画填充模式</h3><blockquote>
<p><code>animation-fill-mode</code> 属性为 <code>forwards</code>，使用户把鼠标悬停在按钮上时，按钮保持高亮</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  <span class="selector-tag">button</span> &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#0F5897</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">10px</span> <span class="number">8px</span> <span class="number">10px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">button</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">animation-name</span>: background-color;</span><br><span class="line">    <span class="attribute">animation-duration</span>: <span class="number">500ms</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">animation-fill-mode</span>: forwards;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">@keyframes</span> background-color &#123;</span><br><span class="line">    <span class="number">100%</span> &#123;</span><br><span class="line">      <span class="attribute">background-color</span>: <span class="number">#4791d0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;<span class="selector-tag">button</span>&gt;Register&lt;/<span class="selector-tag">button</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="CSS创建动画"><a href="#CSS创建动画" class="headerlink" title="CSS创建动画"></a>CSS创建动画</h3><blockquote>
<p>在元素的 <code>position</code> 已有指定值（如 <code>fixed</code> 或者 <code>relative</code>）时，CSS 偏移属性 <code>right</code>、<code>left</code>、<code>top</code>、<code>bottom</code> 可以用在动画规则里创建动作</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="number">100%</span> &#123;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">25px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动画计数"><a href="#动画计数" class="headerlink" title="动画计数"></a>动画计数</h3><blockquote>
<p><code>animation-iteration-count</code>，这个属性允许你控制动画循环的次数</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">animation-iteration-count</span>: <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>在这里动画会在运行 3 次后停止，如果想让动画一直运行，可以把值设置成 <code>infinite</code></p>
<h3 id="关键字更改动画定时器"><a href="#关键字更改动画定时器" class="headerlink" title="关键字更改动画定时器"></a>关键字更改动画定时器</h3><blockquote>
<p>在 CSS 动画里，<code>animation-timing-function</code> 用来定义动画的速度曲线。 速度曲线决定了动画从一套 CSS 样式变为另一套所用的时间</p>
</blockquote>
<p>有一些预定义的关键字可用于常见的选项。</p>
<p>默认值是 <code>ease</code>，动画以低速开始，然后加快，在结束前变慢。 </p>
<p>其它常用的值包括 <code>ease-out</code>：动画以高速开始，以低速结束；</p>
<p><code>ease-in</code>，动画以低速开始，以高速结束；</p>
<p><code>linear</code>：动画从头到尾的速度是相同的。</p>
<blockquote>
<p>可以用 <code>cubic-bezier</code> 来定义贝塞尔曲线。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">animation-timing-function</span>: <span class="built_in">cubic-bezier</span>(<span class="number">0.25</span>, <span class="number">0.25</span>, <span class="number">0.75</span>, <span class="number">0.75</span>);</span><br></pre></td></tr></table></figure>

<p>在 CSS 里面通过 <code>(x1, y1, x2, y2)</code> 来确定 <code>p1</code> 和 <code>p2</code>。</p>
<p>两个点的 x 和 y 值相等，元素匀速运动。y比x运动得快，元素运动变慢。</p>
<p>x 值只能在 0 到 1，但是 y 值是可以大于 1 的。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
</search>
